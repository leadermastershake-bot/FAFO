<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>METABOTPRIME Enhanced v6.2 - LLM-Powered Trading AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #00ff88;
            user-select: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Enhanced Panel System */
        .draggable-panel {
            position: absolute;
            z-index: 2;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff88;
            border-radius: 8px;
            backdrop-filter: blur(15px);
            resize: both;
            overflow: auto;
            min-width: 250px;
            min-height: 200px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .panel-header {
            background: rgba(0, 255, 136, 0.2);
            padding: 8px 12px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #00ff88;
        }

        .panel-controls {
            display: flex;
            gap: 5px;
        }

        .panel-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }

        .minimize-btn { background: #ffaa00; }
        .maximize-btn { background: #00ff88; }
        .close-btn { background: #ff4444; }

        .panel-content {
            padding: 15px;
            height: calc(100% - 35px);
            overflow-y: auto;
        }

        /* Non-overlapping panel positions */
        #system-panel {
            top: 50px;
            left: 20px;
            width: 300px;
            height: 350px;
        }

        #trading-panel {
            top: 50px;
            right: 20px;
            width: 380px;
            height: 580px;
        }

        #database-panel {
            bottom: 200px;
            left: 20px;
            width: 450px;
            height: 280px;
        }

        #agents-panel {
            top: 50px;
            left: 340px;
            width: 350px;
            height: 450px;
        }

        #admin-panel {
            top: 60px;
            left: 710px;
            width: 500px;
            height: 600px;
            display: none;
            z-index: 1000;
        }

        #chat-panel {
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 160px;
            max-width: calc(100vw - 420px);
        }

        #report-panel {
            top: 70px;
            left: 360px;
            width: 600px;
            height: 500px;
            display: none;
            z-index: 1001;
        }

        /* Enhanced Login Screen */
        #login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .login-form {
            background: rgba(10, 10, 10, 0.98);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
        }

        .login-form h2 {
            color: #00ff88;
            margin-bottom: 30px;
            font-size: 24px;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #00ff88;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            border-radius: 6px;
            color: #00ff88;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }

        button {
            background: rgba(0, 255, 136, 0.15);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 12px 20px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.25);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: rgba(0, 255, 136, 0.3);
        }

        button.danger {
            border-color: #ff4444;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.15);
        }

        button.admin {
            border-color: #ff00ff;
            color: #ff00ff;
            background: rgba(255, 0, 255, 0.15);
        }

        button.warning {
            border-color: #ffaa00;
            color: #ffaa00;
            background: rgba(255, 170, 0, 0.15);
        }

        /* Database Configuration Wizard */
        .db-wizard {
            background: rgba(0, 100, 255, 0.1);
            border: 2px solid #0066cc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .wizard-step {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .wizard-step.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Enhanced Notification System */
        .notification-container {
            position: fixed;
            top: 50px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification {
            background: rgba(0, 255, 136, 0.95);
            color: #000;
            padding: 15px 20px;
            border-radius: 8px;
            transform: translateX(100%);
            transition: all 0.3s ease;
            max-width: 300px;
            word-wrap: break-word;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: rgba(255, 68, 68, 0.95);
            color: #fff;
        }

        .notification.admin {
            background: rgba(255, 0, 255, 0.95);
            color: #fff;
        }

        .notification.warning {
            background: rgba(255, 165, 0, 0.95);
            color: #000;
        }

        .notification.llm {
            background: rgba(0, 200, 255, 0.95);
            color: #000;
        }

        /* Agent Configuration Modal */
        .agent-config-card {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .agent-config-card:hover {
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
        }

        /* Agent Status Cards */
        .agent-card {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            transition: all 0.3s ease;
        }

        .agent-card:hover {
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
        }

        .agent-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff3333;
        }

        .status-dot.active { background: #00ff88; }
        .status-dot.learning { background: #ffaa00; animation: pulse 1.5s infinite; }
        .status-dot.working { background: #0088ff; animation: pulse 1s infinite; }
        .status-dot.repairing { background: #ff6600; animation: pulse 0.5s infinite; }
        .status-dot.configuring { background: #ff00ff; animation: pulse 0.8s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .repair-status {
            background: rgba(255, 102, 0, 0.1);
            border: 1px solid #ff6600;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 11px;
        }

        /* LLM Processing Indicator */
        .llm-processing {
            background: rgba(0, 200, 255, 0.1);
            border: 1px solid #00c8ff;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 11px;
            animation: pulse 1.2s infinite;
        }

        /* Report Display */
        .report-section {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            font-size: 12px;
        }

        .report-section h4 {
            color: #00ff88;
            margin-bottom: 10px;
            border-bottom: 1px solid #00ff88;
            padding-bottom: 5px;
        }

        .report-metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }

        .report-metric:last-child {
            border-bottom: none;
        }

        /* Database Stats */
        .database-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: rgba(0, 100, 255, 0.1);
            border: 1px solid #0066cc;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            font-size: 11px;
        }

        .backup-schedule {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid #ffa500;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
        }

        /* Wallet Management */
        .wallet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .wallet-card {
            background: rgba(0, 100, 255, 0.1);
            border: 1px solid #0066cc;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .wallet-card:hover {
            background: rgba(0, 100, 255, 0.2);
        }

        .wallet-card.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        /* Progress Bars */
        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            border-radius: 6px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0088ff);
            transition: width 0.5s ease;
        }

        /* Modal Overlays */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal {
            background: rgba(10, 10, 10, 0.98);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 25px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.4);
        }

        /* Menu Bar */
        .menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 35px;
            background: rgba(0, 0, 0, 0.95);
            border-bottom: 1px solid #00ff88;
            z-index: 100;
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 20px;
        }

        .menu-item {
            color: #00ff88;
            cursor: pointer;
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .menu-item:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .menu-separator {
            width: 1px;
            height: 20px;
            background: #00ff88;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.7);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .draggable-panel {
                position: relative !important;
                transform: none !important;
                width: 100% !important;
                height: auto !important;
                margin-bottom: 20px;
                resize: none;
            }

            body {
                overflow-y: auto;
            }
        }
    </style>
<!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.10.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://unpkg.com/tmi.js/dist/tmi.min.js"></script>
</head>
<body>
    <!-- Enhanced Login Screen -->
    <div id="login-screen">
        <div class="login-form">
            <h2>ü§ñ METABOTPRIME v6.2</h2>
            <div class="form-group">
                <label>Username:</label>
                <input type="text" id="username" placeholder="Enter Username" autocomplete="username">
            </div>
            <div class="form-group">
                <label>Password:</label>
                <input type="password" id="password" placeholder="Enter Password" autocomplete="current-password">
            </div>
            <div class="form-group">
                <label>Access Level:</label>
                <select id="access-level">
                    <option value="user">Standard User</option>
                    <option value="admin">Administrator</option>
                    <option value="superadmin">Super Administrator</option>
                </select>
            </div>
            <button onclick="attemptLogin()" class="primary">üîê LOGIN</button>
            <button onclick="requestAccess()">üìù REQUEST ACCESS</button>
            <div style="margin-top: 20px; font-size: 11px; color: #666;">
                Super Admin: LMS only<br>
                v6.2: Enhanced LLM Integration
            </div>
        </div>
    </div>

    <!-- Enhanced Notification Container -->
    <div id="notification-container" class="notification-container"></div>

    <!-- Menu Bar -->
    <div class="menu-bar" style="display: none;" id="menu-bar">
        <span style="color: #00ff88; font-weight: bold;">METABOTPRIME v6.2</span>
        <div class="menu-separator"></div>
        <div class="menu-item" onclick="togglePanel('system-panel')">üìä System</div>
        <div class="menu-item" onclick="togglePanel('trading-panel')">üìà Trading</div>
        <div class="menu-item" onclick="togglePanel('database-panel')">üóÉÔ∏è Database</div>
        <div class="menu-item" onclick="togglePanel('agents-panel')">ü§ñ Agents</div>
        <div class="menu-item" onclick="togglePanel('chat-panel')">üí¨ Chat</div>
        <div class="menu-separator"></div>
        <div class="menu-item" onclick="openWalletManager()">üíõ Wallets</div>
        <div class="menu-item" onclick="openNodeManager()">üåê Nodes</div>
        <div class="menu-item" onclick="openReportPanel()">üìã Reports</div>
        <div class="menu-item" onclick="togglePanel('twitch-panel')">üëæ Twitch</div>
        <div class="menu-separator"></div>
        <div class="menu-item admin" onclick="openAdminPanel()" id="admin-menu" style="display: none;">‚öôÔ∏è Admin</div>
        <div style="margin-left: auto;">
            <span id="user-display" style="color: #00ff88;"></span>
            <div class="menu-item" onclick="logout()">üö™ Logout</div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- System Status Panel -->
    <div id="system-panel" class="draggable-panel">
        <div class="panel-header">
            <span>ü§ñ METABOTPRIME System</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('system-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('system-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('system-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content">
            <div><span class="status-dot active"></span>System: <span id="system-status">Online</span></div>
            <div>üß† Learning Mode: <span id="learning-mode">Active</span></div>
            <div>‚ö° Active Agents: <span id="active-agents">0</span></div>
            <div>üìä Database: <span id="db-status">Configuring...</span></div>
            <div>üéØ Success Rate: <span id="success-rate">0%</span></div>
            <div>üíπ Total Trades: <span id="total-trades">0</span></div>
            <div>‚è±Ô∏è Uptime: <span id="uptime">00:00:00</span></div>

            <div style="margin-top: 15px;">
                <div>üîê Security Level: <span id="security-level">HIGH</span></div>
                <div>üåê Network Health: <span id="network-health">OPTIMAL</span></div>
                <div>‚öñÔ∏è System Load: <span id="system-load">12%</span></div>
                <div>üß† LLM Status: <span id="llm-status">Ready</span></div>
            </div>

            <div style="margin-top: 15px;">
                <h4>üîß Quick Actions</h4>
                <button onclick="performSystemHealthCheck()" style="width: 100%; margin: 5px 0;">üè• Health Check</button>
                <button onclick="optimizeSystem()" style="width: 100%; margin: 5px 0;">‚ö° Optimize System</button>
                <button onclick="generateSystemReport()" style="width: 100%; margin: 5px 0;">üìã Generate Report</button>
                <button onclick="llmDiagnose()" style="width: 100%; margin: 5px 0;" class="admin">üß† LLM Diagnose</button>
            </div>
        </div>
    </div>

    <!-- Trading Dashboard Panel -->
    <div id="trading-panel" class="draggable-panel">
        <div class="panel-header">
            <span>üìà Trading Dashboard</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('trading-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('trading-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('trading-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content">
            <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 136, 255, 0.2)); border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 18px;">üí∞ Current Capital: $<span id="current-capital">0.00</span></div>
                <div>üéØ Target: $<span id="target-amount">1000.00</span></div>
                <div style="color: #00ff88;">üìä Progress: <span id="progress-percent">0.0%</span></div>
            </div>

            <div class="wallet-grid">
                <div class="wallet-card active" id="trading-wallet">
                    <div>ü¶æ Trading Wallet</div>
                    <div>$<span id="trading-balance">0.00</span></div>
                </div>
                <div class="wallet-card" id="holding-wallet">
                    <div>üíé Holding Wallet</div>
                    <div>$<span id="holding-balance">0.00</span></div>
                </div>
            </div>

            <div style="background: rgba(255, 0, 100, 0.1); border: 1px solid #ff0066; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4>ü§ñ Autonomous Trading</h4>
                <div style="display: flex; gap: 10px; margin: 10px 0;">
                    <button id="auto-trade-btn" onclick="toggleAutonomousTrading()" class="primary" disabled>‚è≥ Configuring...</button>
                    <button onclick="emergencyStop()" class="danger">üõë Emergency Stop</button>
                </div>

                <div style="margin: 10px 0;">
                    Risk Level:
                    <select id="risk-level" onchange="updateRiskLevel()">
                        <option value="conservative">Conservative (5%)</option>
                        <option value="moderate" selected>Moderate (15%)</option>
                        <option value="aggressive">Aggressive (35%)</option>
                    </select>
                </div>
            </div>

            <div style="background: rgba(0, 255, 136, 0.05); border: 1px solid #00ff88; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4>üìä Recent Performance</h4>
                <div id="recent-trades" style="max-height: 120px; overflow-y: auto; background: rgba(0, 0, 0, 0.5); padding: 8px; border-radius: 4px; font-size: 10px;">
                    <div style="text-align: center; color: #666;">No trades executed yet...</div>
                </div>
            </div>

            <div style="background: rgba(255, 165, 0, 0.1); border: 1px solid #ffa500; border-radius: 8px; padding: 15px;">
                <h4>üéØ Learning Progress</h4>
                <div style="margin: 8px 0;">
                    Pattern Recognition:
                    <div class="progress-bar"><div class="progress-fill" id="pattern-progress" style="width: 0%"></div></div>
                </div>
                <div style="margin: 8px 0;">
                    Risk Assessment:
                    <div class="progress-bar"><div class="progress-fill" id="risk-progress" style="width: 0%"></div></div>
                </div>
                <div style="margin: 8px 0;">
                    Market Timing:
                    <div class="progress-bar"><div class="progress-fill" id="timing-progress" style="width: 0%"></div></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Database Management Panel -->
    <div id="database-panel" class="draggable-panel">
        <div class="panel-header">
            <span>üóÉÔ∏è Database Management</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('database-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('database-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('database-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content">
            <!-- Database Configuration Wizard -->
            <div id="db-wizard" class="db-wizard" style="display: none;">
                <h4>üîß Database Setup Wizard</h4>
                <div class="wizard-step active" id="wizard-step-1">
                    <p>Select database type:</p>
                    <select id="db-type-select" onchange="selectDatabaseType()">
                        <option value="">Choose database type...</option>
                        <option value="mongodb">MongoDB (Recommended)</option>
                        <option value="postgresql">PostgreSQL</option>
                        <option value="mysql">MySQL</option>
                    </select>
                </div>

                <div class="wizard-step" id="wizard-step-2">
                    <div id="connection-config">
                        <!-- Dynamic configuration based on DB type -->
                    </div>
                    <button onclick="testDatabaseConnection()" class="primary">üîå Test Connection</button>
                    <button onclick="llmConfigureDatabase()" class="admin">üß† LLM Auto-Configure</button>
                </div>

                <div class="wizard-step" id="wizard-step-3">
                    <p>‚úÖ Database connected successfully!</p>
                    <button onclick="completeDatabaseSetup()" class="primary">üöÄ Complete Setup</button>
                </div>
            </div>

            <!-- Database Status (shown when configured) -->
            <div id="db-status-section" style="display: none;">
                <div class="database-stats">
                    <div class="stat-card">
                        <div>üìà Records</div>
                        <div id="db-records">0</div>
                    </div>
                    <div class="stat-card">
                        <div>üíæ Size</div>
                        <div id="db-size">0MB</div>
                    </div>
                    <div class="stat-card">
                        <div>üîÑ Backups</div>
                        <div id="backup-count">0</div>
                    </div>
                </div>

                <div class="backup-schedule">
                    <h4>‚è∞ Backup Schedule</h4>
                    <div style="font-size: 10px; margin: 5px 0;">
                        <div>Next Backup: <span id="next-backup">Not scheduled</span></div>
                        <div>Last Backup: <span id="last-backup">Never</span></div>
                        <div>Backup Frequency: <span id="backup-frequency">Every 6 hours</span></div>
                    </div>
                    <button onclick="createManualBackup()" style="width: 100%; margin: 5px 0;" disabled id="backup-btn">üíæ Configure Database First</button>
                </div>

                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button onclick="analyzeHistoricalData()" style="flex: 1;" disabled id="analyze-btn">üìä Analyze Data</button>
                    <button onclick="optimizeStrategies()" style="flex: 1;" disabled id="optimize-btn">‚ö° Optimize</button>
                    <button onclick="exportData()" style="flex: 1;" disabled id="export-btn">üì§ Export</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Multi-Agent System Panel -->
    <div id="agents-panel" class="draggable-panel">
        <div class="panel-header">
            <span>ü§ñ Multi-Agent System</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('agents-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('agents-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('agents-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content" id="agents-content">
            <div style="text-align: center; color: #666; padding: 20px;">
                üîÑ Initializing agent system...
            </div>
        </div>
    </div>

    <!-- Chat Interface Panel -->
    <div id="chat-panel" class="draggable-panel">
        <div class="panel-header">
            <span>üí¨ LLM Communication Hub</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('chat-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('chat-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('chat-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content">
            <div id="chat-log" style="height: 80px; overflow-y: auto; margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.6); border: 1px solid #004400; border-radius: 4px; font-size: 11px;"></div>
            <input type="text" id="user-input" placeholder="Ask METABOTPRIME LLM about trading, configurations, or request automated assistance..." onkeypress="handleInput(event)" style="width: 100%; background: rgba(0, 0, 0, 0.7); border: 1px solid #00ff88; color: #00ff88; padding: 8px; font-family: inherit; border-radius: 4px; font-size: 12px;">
        </div>
    </div>

    <!-- Reports Panel -->
    <div id="report-panel" class="draggable-panel">
        <div class="panel-header">
            <span>üìã System Reports</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('report-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('report-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('report-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content" id="report-content">
            <div style="text-align: center; color: #666; padding: 20px;">
                üìã No reports generated yet
            </div>
        </div>
    </div>

    <!-- Enhanced Super Admin Panel -->
    <div id="admin-panel" class="draggable-panel">
        <div class="panel-header">
            <span>‚öôÔ∏è Super Admin Control</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('admin-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('admin-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closeAdminPanel()">√ó</div>
            </div>
        </div>
        <div class="panel-content">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <h4>üë• User Management</h4>
                    <div style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 6px; margin: 10px 0; max-height: 150px; overflow-y: auto;">
                        <div id="user-requests">
                            <div style="text-align: center; color: #666;">No pending requests</div>
                        </div>
                    </div>
                    <button onclick="refreshUserRequests()" style="width: 100%;">üîÑ Refresh Requests</button>
                </div>

                <div>
                    <h4>üîê Security Keys</h4>
                    <div style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 6px; margin: 10px 0;">
                        <div>Master Key: <span id="master-key">***ENCRYPTED***</span></div>
                        <div>Expires: <span id="key-expiry">30 days</span></div>
                        <div>Status: <span style="color: #00ff88;">Active</span></div>
                    </div>
                    <button onclick="generateNewKey()" style="width: 100%; margin: 5px 0;">üîë Generate New Key</button>
                    <button onclick="renewSubscriptions()" style="width: 100%; margin: 5px 0;">‚ôªÔ∏è Renew Subscriptions</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h4>ü§ñ Agent Management</h4>
                <div style="display: flex; gap: 10px; margin: 10px 0;">
                    <button onclick="openAgentConfiguration()" style="flex: 1;">‚öôÔ∏è Configure Agents</button>
                    <button onclick="llmOptimizeAgents()" style="flex: 1;" class="admin">üß† LLM Optimize</button>
                </div>
                <div style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 6px; margin: 10px 0; font-size: 11px;">
                    <div>Active Agents: <span id="admin-active-agents">0</span></div>
                    <div>Avg Performance: <span id="admin-avg-performance">0%</span></div>
                    <div>Issues Detected: <span id="admin-issues">0</span></div>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h4>üåê Node Network</h4>
                <div class="database-stats" style="margin-bottom: 15px;">
                    <div class="stat-card">
                        <div>üñ•Ô∏è Active Nodes</div>
                        <div id="active-nodes">7</div>
                    </div>
                    <div class="stat-card">
                        <div>üìä Network Load</div>
                        <div id="network-load">34%</div>
                    </div>
                    <div class="stat-card">
                        <div>üí∞ Revenue Share</div>
                        <div id="revenue-share">$2,345</div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="optimizeNetwork()" style="flex: 1;">‚ö° Optimize</button>
                    <button onclick="distributeWork()" style="flex: 1;">üìã Distribute</button>
                    <button onclick="viewNetworkHealth()" style="flex: 1;">üè• Health</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h4>üìà System Analytics</h4>
                <div style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 6px; margin: 10px 0; font-size: 11px;">
                    <div>Total Users: <span id="total-users">1,247</span></div>
                    <div>Active Subscriptions: <span id="active-subs">892</span></div>
                    <div>System Uptime: <span id="system-uptime">99.97%</span></div>
                    <div>Daily Revenue: <span id="daily-revenue">$4,567</span></div>
                </div>
                <button onclick="generateAnalyticsReport()" style="width: 100%;">üìä Generate Full Report</button>
            </div>
        </div>
    </div>

    <!-- Agent Configuration Modal -->
    <div id="agent-config-modal" class="modal-overlay">
        <div class="modal">
            <h3>ü§ñ Agent Configuration Panel</h3>

            <div id="agent-config-list">
                <!-- Agents will be populated here -->
            </div>

            <div style="margin-top: 20px;">
                <h4>‚ûï Create New Agent</h4>
                <div class="form-group">
                    <label>Agent Name:</label>
                    <input type="text" id="new-agent-name" placeholder="e.g., Market Scanner">
                </div>
                <div class="form-group">
                    <label>Agent Type:</label>
                    <select id="new-agent-type">
                        <option value="trading">Trading Specialist</option>
                        <option value="analysis">Data Analysis</option>
                        <option value="monitoring">System Monitoring</option>
                        <option value="research">Market Research</option>
                        <option value="custom">Custom Configuration</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Capabilities (comma-separated):</label>
                    <input type="text" id="new-agent-capabilities" placeholder="pattern_recognition, risk_assessment">
                </div>
                <button onclick="createAgentFromConfig()" class="primary">üöÄ Create Agent</button>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="closeModal('agent-config-modal')">‚úÖ Close</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Wallet Manager Modal -->
    <div id="wallet-modal" class="modal-overlay">
        <div class="modal">
            <h3>üíõ Multi-Wallet Management</h3>

            <div style="margin-bottom: 20px;">
                <h4>üîó Connected Wallets</h4>
                <div id="wallet-list">
                    <div style="text-align: center; color: #666;">No wallets connected</div>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h4>‚ûï Add New Wallet</h4>
                <div class="form-group">
                    <label>Wallet Type:</label>
                    <select id="wallet-type" onchange="handleWalletTypeChange()">
                        <option value="">Select wallet type...</option>
                        <option value="metamask">MetaMask (Auto-detect)</option>
                        <option value="coinbase">Coinbase Wallet</option>
                        <option value="manual">Manual Entry</option>
                        <option value="hardware">Hardware Wallet</option>
                    </select>
                </div>
                <div class="form-group" id="manual-wallet-fields" style="display: none;">
                    <label>Wallet Address:</label>
                    <input type="text" id="wallet-address" placeholder="0x...">
                    <label>Private Key (Optional):</label>
                    <input type="password" id="private-key" placeholder="For trading access only">
                </div>
                <div class="form-group">
                    <label>Wallet Name:</label>
                    <input type="text" id="wallet-name" placeholder="My Trading Wallet">
                </div>
                <button onclick="addWallet()" class="primary" id="add-wallet-btn" disabled>‚ûï Add Wallet</button>
                <button onclick="llmConfigureWallet()" class="admin" id="llm-wallet-btn" disabled>üß† LLM Auto-Configure</button>
            </div>

            <div style="text-align: center;">
                <button onclick="closeModal('wallet-modal')">‚úÖ Close</button>
            </div>
        </div>
    </div>

    <!-- Twitch Integration Panel -->
    <div id="twitch-panel" class="draggable-panel" style="top: 500px; left: 710px; width: 350px; height: 400px; display: none;">
        <div class="panel-header">
            <span>üëæ Twitch Integration</span>
            <div class="panel-controls">
                <div class="panel-btn minimize-btn" onclick="minimizePanel('twitch-panel')">‚àí</div>
                <div class="panel-btn maximize-btn" onclick="maximizePanel('twitch-panel')">‚ñ°</div>
                <div class="panel-btn close-btn" onclick="closePanel('twitch-panel')">√ó</div>
            </div>
        </div>
        <div class="panel-content">
            <div class="form-group">
                <label>Twitch Channel:</label>
                <input type="text" id="twitch-channel" placeholder="Enter channel name">
            </div>
            <div class="form-group">
                <label>Bot Username:</label>
                <input type="text" id="twitch-username" placeholder="Bot's username">
            </div>
            <div class="form-group">
                <label>OAuth Token:</label>
                <input type="password" id="twitch-oauth" placeholder="oauth:...">
            </div>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button onclick="twitchManager.connect()" class="primary" id="twitch-connect-btn">üîå Connect</button>
                <button onclick="twitchManager.disconnect()" class="danger" id="twitch-disconnect-btn" disabled>üîå Disconnect</button>
            </div>
            <div>Status: <span id="twitch-status" style="color: #ff4444;">Disconnected</span></div>
            <h4 style="margin-top: 15px;">Twitch Chat</h4>
            <div id="twitch-chat-log" style="height: 150px; overflow-y: auto; margin-top: 10px; padding: 10px; background: rgba(0, 0, 0, 0.6); border: 1px solid #004400; border-radius: 4px; font-size: 11px;">
            </div>
        </div>
    </div>

    <!-- Node Manager Modal -->
    <div id="node-modal" class="modal-overlay">
        <div class="modal">
            <h3>üåê Node Network Manager</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div>
                    <h4>üìä Network Status</h4>
                    <div style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 8px;">
                        <div>LAN Nodes: <span style="color: #00ff88;" id="lan-nodes">3 Active</span></div>
                        <div>WAN Nodes: <span style="color: #00ff88;" id="wan-nodes">12 Active</span></div>
                        <div>Web Nodes: <span style="color: #00ff88;" id="web-nodes">47 Active</span></div>
                        <div>Network Latency: <span style="color: #00ff88;" id="network-latency">23ms</span></div>
                        <div>Throughput: <span style="color: #00ff88;" id="network-throughput">1.2GB/s</span></div>
                    </div>
                </div>

                <div>
                    <h4>‚öñÔ∏è Load Distribution</h4>
                    <div style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 8px;">
                        <div>Trading Tasks: <span id="trading-load">45</span>%</div>
                        <div class="progress-bar"><div class="progress-fill" id="trading-progress" style="width: 45%"></div></div>
                        <div>Learning Tasks: <span id="learning-load">30</span>%</div>
                        <div class="progress-bar"><div class="progress-fill" id="learning-progress-bar" style="width: 30%"></div></div>
                        <div>Data Processing: <span id="processing-load">25</span>%</div>
                        <div class="progress-bar"><div class="progress-fill" id="processing-progress" style="width: 25%"></div></div>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h4>üîß Node Configuration</h4>
                <div class="form-group">
                    <label>Node Priority:</label>
                    <select id="node-priority">
                        <option value="high">High Performance</option>
                        <option value="balanced" selected>Balanced</option>
                        <option value="efficient">Energy Efficient</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Work Distribution:</label>
                    <select id="work-distribution">
                        <option value="auto" selected>Auto-Balance</option>
                        <option value="trading">Trading Focus</option>
                        <option value="learning">Learning Focus</option>
                        <option value="processing">Processing Focus</option>
                    </select>
                </div>
                <button onclick="applyNodeConfig()" class="primary">‚öôÔ∏è Apply Configuration</button>
                <button onclick="llmOptimizeNodes()" class="admin">üß† LLM Optimize</button>
            </div>

            <div style="text-align: center;">
                <button onclick="closeModal('node-modal')">‚úÖ Close</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Global State Management
        const STATE = {
            user: {
                username: '',
                accessLevel: 'user',
                isLoggedIn: false,
                permissions: []
            },
            database: {
                configured: false,
                type: null,
                connected: false,
                lastBackup: null,
                backupInProgress: false,
                records: 0,
                size: '0MB',
                backupCount: 0,
                lastUpdate: null
            },
            connections: {
                coinbase: { connected: false, environment: 'sandbox' },
                metamask: { connected: false, account: null }
            },
            trading: {
                capital: 0.00,
                target: 1000.00,
                holdingBalance: 0.00,
                isAutoTrading: false,
                totalTrades: 0,
                successfulTrades: 0,
                initialized: false
            },
            agents: new Map(),
            notifications: {
                active: new Map(),
                messageHistory: new Set(),
                lastMessageTime: new Map()
            },
            wallets: new Map(),
            panels: {
                minimized: new Set(),
                positions: new Map()
            },
            system: {
                initialized: false,
                lastHealthCheck: null
            },
            llm: {
                isProcessing: false,
                lastAction: null,
                processingQueue: [],
                timeout: 30000, // 30 seconds timeout
                fallbackMode: false
            }
        };

        // Enhanced LLM Integration System
        class LLMIntegration {
            constructor() {
                this.processingQueue = [];
                this.isProcessing = false;
                this.timeout = 30000; // 30 seconds
                this.maxRetries = 3;
            }

            async processRequest(task, parameters = {}, priority = 'normal') {
                const request = {
                    id: `llm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    task: task,
                    parameters: parameters,
                    priority: priority,
                    timestamp: Date.now(),
                    retries: 0,
                    status: 'pending'
                };

                this.processingQueue.push(request);
                this.sortQueue();

                if (!this.isProcessing) {
                    this.processQueue();
                }

                return request.id;
            }

            sortQueue() {
                this.processingQueue.sort((a, b) => {
                    const priorityMap = { 'critical': 0, 'high': 1, 'normal': 2, 'low': 3 };
                    return priorityMap[a.priority] - priorityMap[b.priority];
                });
            }

            async processQueue() {
                if (this.isProcessing || this.processingQueue.length === 0) return;

                this.isProcessing = true;
                STATE.llm.isProcessing = true;
                document.getElementById('llm-status').textContent = 'Processing...';

                while (this.processingQueue.length > 0) {
                    const request = this.processingQueue.shift();

                    try {
                        await this.executeTask(request);
                    } catch (error) {
                        await this.handleTaskFailure(request, error);
                    }
                }

                this.isProcessing = false;
                STATE.llm.isProcessing = false;
                document.getElementById('llm-status').textContent = 'Ready';
            }

            async executeTask(request) {
                addChatMessage('llm', `üß† Processing: ${request.task}`);
                this.showLLMProcessing(request.task);

                const timeout = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('LLM timeout')), this.timeout)
                );

                const taskPromise = this.performTask(request);

                try {
                    const result = await Promise.race([taskPromise, timeout]);
                    request.status = 'completed';
                    this.hideLLMProcessing();
                    addChatMessage('llm', `‚úÖ Task completed: ${request.task}`);
                    notificationManager.show(`LLM completed: ${request.task}`, 'llm');
                    return result;
                } catch (error) {
                    throw error;
                }
            }

            async performTask(request) {
                const { task, parameters } = request;

                switch (task) {
                    case 'configure_database':
                        return await this.configureDatabaseTask(parameters);
                    case 'configure_wallet':
                        return await this.configureWalletTask(parameters);
                    case 'optimize_agents':
                        return await this.optimizeAgentsTask(parameters);
                    case 'diagnose_system':
                        return await this.diagnoseSystemTask(parameters);
                    case 'resolve_issue':
                        return await this.resolveIssueTask(parameters);
                    case 'optimize_nodes':
                        return await this.optimizeNodesTask(parameters);
                    default:
                        throw new Error(`Unknown task: ${task}`);
                }
            }

            async configureDatabaseTask(parameters) {
                // Simulate LLM database configuration
                await this.delay(3000);

                const dbType = parameters.dbType || 'mongodb';
                const config = {
                    mongodb: { connectionString: 'mongodb://localhost:27017/metabotprime_llm' },
                    postgresql: { host: 'localhost', port: 5432, database: 'metabotprime_llm', user: 'postgres', password: 'password' },
                    mysql: { host: 'localhost', port: 3306, database: 'metabotprime_llm', user: 'root', password: 'password' }
                };

                const result = await dbManager.configureDatabase(dbType, config[dbType]);
                if (result) {
                    addChatMessage('llm', `üß† Database auto-configured: ${dbType.toUpperCase()}`);
                    return { success: true, dbType: dbType };
                } else {
                    throw new Error('Database configuration failed');
                }
            }

            async configureWalletTask(parameters) {
                await this.delay(2000);

                // Try MetaMask first, fallback to manual
                try {
                    if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask) {
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        if (accounts.length > 0) {
                            const walletData = {
                                id: `wallet_${Date.now()}`,
                                name: parameters.name || 'LLM Auto-Configured Wallet',
                                type: 'metamask',
                                address: accounts[0],
                                balance: await walletManager.getBalance(accounts[0]),
                                lastSync: Date.now()
                            };

                            STATE.wallets.set(walletData.id, walletData);
                            updateWalletList();
                            addChatMessage('llm', `üß† MetaMask wallet auto-configured: ${accounts[0].substring(0, 10)}...`);
                            return { success: true, wallet: walletData };
                        }
                    }
                    throw new Error('MetaMask not available');
                } catch (error) {
                    // Fallback to manual configuration
                    addChatMessage('llm', '‚ö†Ô∏è MetaMask failed, creating manual wallet entry');
                    const manualWallet = {
                        id: `wallet_${Date.now()}`,
                        name: parameters.name || 'LLM Manual Wallet',
                        type: 'manual',
                        address: '0x' + Array(40).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join(''),
                        balance: 0,
                        lastSync: Date.now(),
                        note: 'Auto-configured by LLM - Update address manually'
                    };

                    STATE.wallets.set(manualWallet.id, manualWallet);
                    updateWalletList();
                    addChatMessage('llm', `üß† Manual wallet created: ${manualWallet.address.substring(0, 10)}... (Update required)`);
                    notificationManager.show('Manual wallet created - Please update address', 'warning');
                    return { success: true, wallet: manualWallet, fallback: true };
                }
            }

            async optimizeAgentsTask(parameters) {
                await this.delay(4000);

                let optimized = 0;
                for (const [id, agent] of agentSystem.agents) {
                    if (agent.performance < 0.5) {
                        agent.performance = Math.min(1, agent.performance + Math.random() * 0.3 + 0.2);
                        agent.task = 'LLM Optimized - ' + agent.task;
                        optimized++;
                        addChatMessage('llm', `üß† Optimized agent: ${agent.name}`);
                    }
                }

                agentSystem.updateAgentUI();
                return { success: true, optimized: optimized };
            }

            async diagnoseSystemTask(parameters) {
                await this.delay(3000);

                const issues = [];
                const recommendations = [];

                // Check database
                if (!STATE.database.configured) {
                    issues.push('Database not configured');
                    recommendations.push('Configure database for optimal performance');
                }

                // Check trading system
                if (!STATE.trading.initialized) {
                    issues.push('Trading system not initialized');
                    recommendations.push('Initialize trading system with starting capital');
                }

                // Check agents
                const lowPerformanceAgents = Array.from(agentSystem.agents.values()).filter(a => a.performance < 0.3);
                if (lowPerformanceAgents.length > 0) {
                    issues.push(`${lowPerformanceAgents.length} agents underperforming`);
                    recommendations.push('Run agent optimization to improve performance');
                }

                // Check wallets
                if (STATE.wallets.size === 0) {
                    issues.push('No wallets configured');
                    recommendations.push('Add wallets for trading operations');
                }

                const diagnosis = {
                    issues: issues,
                    recommendations: recommendations,
                    systemHealth: Math.max(0, 100 - (issues.length * 15)),
                    timestamp: new Date().toISOString()
                };

                addChatMessage('llm', `üß† System diagnosis complete: ${diagnosis.systemHealth}% health, ${issues.length} issues found`);

                return diagnosis;
            }

            async resolveIssueTask(parameters) {
                const { issue, action } = parameters;
                await this.delay(2500);

                let resolved = false;
                let message = '';

                switch (issue) {
                    case 'database_not_configured':
                        if (action === 'auto_configure') {
                            await this.configureDatabaseTask({ dbType: 'mongodb' });
                            resolved = true;
                            message = 'Database auto-configured successfully';
                        }
                        break;
                    case 'wallet_connection_failed':
                        if (action === 'create_manual') {
                            await this.configureWalletTask({ name: 'Auto-Recovery Wallet' });
                            resolved = true;
                            message = 'Manual wallet created as fallback';
                        }
                        break;
                    case 'agent_performance_low':
                        if (action === 'optimize') {
                            await this.optimizeAgentsTask({});
                            resolved = true;
                            message = 'Agent performance optimized';
                        }
                        break;
                }

                return { resolved: resolved, message: message };
            }

            async optimizeNodesTask(parameters) {
                await this.delay(3500);

                // Simulate node optimization
                const improvements = {
                    latencyReduction: Math.floor(Math.random() * 30) + 10,
                    throughputIncrease: Math.floor(Math.random() * 25) + 15,
                    loadBalancing: Math.floor(Math.random() * 20) + 10
                };

                addChatMessage('llm', `üß† Node optimization complete: -${improvements.latencyReduction}ms latency, +${improvements.throughputIncrease}% throughput`);

                return improvements;
            }

            async handleTaskFailure(request, error) {
                request.retries++;
                addChatMessage('llm', `‚ö†Ô∏è Task failed: ${request.task} (${error.message})`);

                if (request.retries < this.maxRetries) {
                    addChatMessage('llm', `üîÑ Retrying task: ${request.task} (Attempt ${request.retries + 1})`);
                    this.processingQueue.unshift(request); // Re-add to front of queue
                } else {
                    addChatMessage('llm', `‚ùå Task failed after ${this.maxRetries} attempts: ${request.task}`);
                    notificationManager.show(`LLM task failed: ${request.task}`, 'error');

                    // Request user intervention
                    await this.requestUserIntervention(request, error);
                }
            }

            async requestUserIntervention(request, error) {
                const fallbackActions = {
                    'configure_database': 'Please configure database manually using the Database panel',
                    'configure_wallet': 'Please add wallet manually using the Wallet Manager',
                    'optimize_agents': 'Please check agent status and restart if needed',
                    'diagnose_system': 'Please run manual health check',
                    'resolve_issue': 'Please resolve the issue manually',
                    'optimize_nodes': 'Please check node configuration manually'
                };

                const fallbackMessage = fallbackActions[request.task] || 'Please handle this task manually';
                addChatMessage('system', `üîß Manual intervention required: ${fallbackMessage}`);
                notificationManager.show(`Manual intervention needed: ${request.task}`, 'warning', 10000);

                STATE.llm.fallbackMode = true;
            }

            showLLMProcessing(task) {
                const chatLog = document.getElementById('chat-log');
                const processingDiv = document.createElement('div');
                processingDiv.className = 'llm-processing';
                processingDiv.id = 'llm-processing-indicator';
                processingDiv.innerHTML = `üß† LLM Processing: ${task}...`;
                chatLog.appendChild(processingDiv);
                chatLog.scrollTop = chatLog.scrollHeight;
            }

            hideLLMProcessing() {
                const indicator = document.getElementById('llm-processing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Enhanced Notification System
        class NotificationManager {
            constructor() {
                this.container = document.getElementById('notification-container');
                this.activeNotifications = new Map();
                this.messageQueue = [];
                this.isProcessing = false;
            }

            show(message, type = 'success', duration = 5000) {
                const messageKey = `${type}-${message}`;
                const now = Date.now();

                // Check for duplicate messages
                if (STATE.notifications.messageHistory.has(messageKey)) {
                    const lastTime = STATE.notifications.lastMessageTime.get(messageKey) || 0;
                    if (now - lastTime < 3000) { // 3 second cooldown
                        return; // Skip duplicate message
                    }
                }

                // Update tracking
                STATE.notifications.messageHistory.add(messageKey);
                STATE.notifications.lastMessageTime.set(messageKey, now);

                // Queue the message
                this.messageQueue.push({ message, type, duration, timestamp: now });

                if (!this.isProcessing) {
                    this.processQueue();
                }
            }

            async processQueue() {
                this.isProcessing = true;

                while (this.messageQueue.length > 0) {
                    const notification = this.messageQueue.shift();
                    await this.displayNotification(notification);
                    await this.delay(500); // 500ms between notifications
                }

                this.isProcessing = false;
            }

            async displayNotification({ message, type, duration }) {
                const notification = document.createElement('div');
                const id = Date.now() + Math.random();

                notification.className = `notification ${type}`;
                notification.textContent = message;
                notification.dataset.id = id;

                this.container.appendChild(notification);
                this.activeNotifications.set(id, notification);

                // Show animation
                setTimeout(() => notification.classList.add('show'), 100);

                // Auto remove
                setTimeout(() => {
                    this.removeNotification(id);
                }, duration);
            }

            removeNotification(id) {
                const notification = this.activeNotifications.get(id);
                if (notification) {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                        this.activeNotifications.delete(id);
                    }, 300);
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Enhanced Database Management System
        class DatabaseManager {
            constructor() {
                this.isConfigured = false;
                this.type = null;
                this.connection = null;
                this.backupSchedule = null;
                this.updateThrottle = new Map();
            }

            async configureDatabase(type, config) {
                try {
                    notificationManager.show('Configuring database...', 'admin', 3000);

                    // Simulate connection testing
                    await this.delay(2000);

                    if (type === 'mongodb') {
                        await this.configureMongoDb(config);
                    } else if (type === 'postgresql') {
                        await this.configurePostgreSQL(config);
                    } else if (type === 'mysql') {
                        await this.configureMysql(config);
                    }

                    this.type = type;
                    this.isConfigured = true;
                    STATE.database.configured = true;
                    STATE.database.connected = true;
                    STATE.database.type = type;

                    this.startBackupScheduler();
                    this.enableDatabaseButtons();

                    addChatMessage('database', `‚úÖ ${type.toUpperCase()} database configured successfully`);
                    notificationManager.show(`Database ${type} connected successfully!`, 'admin');

                    // Update UI
                    document.getElementById('db-status').textContent = 'Connected';
                    document.getElementById('db-wizard').style.display = 'none';
                    document.getElementById('db-status-section').style.display = 'block';

                    return true;

                } catch (error) {
                    notificationManager.show(`Database connection failed: ${error.message}`, 'error');
                    addChatMessage('database', `‚ùå Database configuration failed: ${error.message}`);
                    return false;
                }
            }

            async configureMongoDb(config) {
                const connectionString = config.connectionString || 'mongodb://localhost:27017/metabotprime';
                addChatMessage('database', `üîå Connecting to MongoDB: ${connectionString}`);

                this.connection = {
                    type: 'mongodb',
                    url: connectionString,
                    connected: true
                };

                await this.initializeCollections();
            }

            async configurePostgreSQL(config) {
                const connectionString = `postgresql://${config.user}:${config.password}@${config.host}:${config.port}/${config.database}`;
                addChatMessage('database', `üîå Connecting to PostgreSQL: ${config.host}:${config.port}`);

                this.connection = {
                    type: 'postgresql',
                    config: config,
                    connected: true
                };

                await this.initializeTables();
            }

            async configureMysql(config) {
                addChatMessage('database', `üîå Connecting to MySQL: ${config.host}:${config.port}`);

                this.connection = {
                    type: 'mysql',
                    config: config,
                    connected: true
                };

                await this.initializeTables();
            }

            async initializeCollections() {
                const collections = ['trades', 'agents', 'users', 'backups', 'analytics'];
                for (const collection of collections) {
                    addChatMessage('database', `üìã Creating collection: ${collection}`);
                    await this.delay(200);
                }
            }

            async initializeTables() {
                const tables = ['trades', 'agents', 'users', 'backups', 'analytics'];
                for (const table of tables) {
                    addChatMessage('database', `üìã Creating table: ${table}`);
                    await this.delay(200);
                }
            }

            async createBackup(type = 'manual') {
                if (!this.isConfigured) {
                    notificationManager.show('Database not configured. Cannot create backup.', 'error');
                    return false;
                }

                const now = Date.now();
                const lastBackupCheck = this.updateThrottle.get('backup') || 0;

                if (type !== 'manual' && now - lastBackupCheck < 23000) {
                    addChatMessage('database', '‚è≥ Backup throttled - too recent. Aborting.');
                    return false;
                }

                if (STATE.database.backupInProgress) {
                    notificationManager.show('Backup already in progress', 'warning');
                    return false;
                }

                try {
                    STATE.database.backupInProgress = true;
                    this.updateThrottle.set('backup', now);

                    notificationManager.show(`Creating ${type} backup...`, 'admin', 3000);
                    addChatMessage('database', `üíæ Starting ${type} backup...`);

                    await this.delay(3000);

                    const backup = {
                        id: `backup_${Date.now()}`,
                        type: type,
                        timestamp: new Date().toISOString(),
                        size: Math.random() * 5 + 1,
                        records: STATE.database.records
                    };

                    STATE.database.backupCount++;
                    STATE.database.lastBackup = now;
                    STATE.database.lastUpdate = now;

                    this.updateDatabaseUI();

                    addChatMessage('database', `‚úÖ ${type} backup completed: ${backup.id}`);
                    notificationManager.show(`${type} backup created successfully!`);

                    return backup;

                } catch (error) {
                    addChatMessage('database', `‚ùå Backup failed: ${error.message}`);
                    notificationManager.show(`Backup failed: ${error.message}`, 'error');
                    return false;
                } finally {
                    STATE.database.backupInProgress = false;
                }
            }

            startBackupScheduler() {
                if (this.backupSchedule) {
                    clearInterval(this.backupSchedule);
                }

                this.backupSchedule = setInterval(() => {
                    this.createBackup('scheduled');
                }, 6 * 60 * 60 * 1000); // 6 hours

                addChatMessage('database', '‚è∞ Backup scheduler activated (every 6 hours)');
            }

            enableDatabaseButtons() {
                document.getElementById('backup-btn').disabled = false;
                document.getElementById('backup-btn').textContent = 'üíæ Create Manual Backup';
                document.getElementById('analyze-btn').disabled = false;
                document.getElementById('optimize-btn').disabled = false;
                document.getElementById('export-btn').disabled = false;
            }

            updateDatabaseUI() {
                document.getElementById('db-records').textContent = STATE.database.records.toLocaleString();
                document.getElementById('db-size').textContent = STATE.database.size;
                document.getElementById('backup-count').textContent = STATE.database.backupCount;

                if (STATE.database.lastBackup) {
                    const lastBackup = new Date(STATE.database.lastBackup).toLocaleString();
                    document.getElementById('last-backup').textContent = lastBackup;

                    const nextBackup = new Date(STATE.database.lastBackup + 6 * 60 * 60 * 1000).toLocaleString();
                    document.getElementById('next-backup').textContent = nextBackup;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Enhanced Multi-Agent System
        class MultiAgentSystem {
            constructor() {
                this.agents = new Map();
                this.repairQueue = new Map();
                this.initialized = false;
            }

            async initialize() {
                if (this.initialized) return;

                addChatMessage('system', 'ü§ñ Initializing multi-agent system...');

                await this.createAgent('ALPHA', 'Strategy Optimizer', ['pattern_recognition', 'strategy_optimization']);
                await this.createAgent('BETA', 'Risk Manager', ['risk_assessment', 'portfolio_management']);
                await this.createAgent('GAMMA', 'Network Monitor', ['system_monitoring', 'health_checks']);

                this.initialized = true;
                this.updateAgentUI();

                addChatMessage('system', '‚úÖ Multi-agent system initialized');
                notificationManager.show('Agent system ready!');
            }

            async createAgent(id, name, capabilities) {
                const agent = {
                    id: id.toLowerCase(),
                    name: `${id} - ${name}`,
                    status: 'initializing',
                    task: 'Preparing for deployment',
                    performance: Math.random() * 0.6 + 0.2, // 20-80% initial performance
                    capabilities: capabilities,
                    lastUpdate: Date.now(),
                    repairTasks: [],
                    configuration: {
                        priority: 'normal',
                        maxTasks: 10,
                        timeout: 30000,
                        retries: 3
                    },
                    execute: () => this.executeAgent(id.toLowerCase())
                };

                this.agents.set(id.toLowerCase(), agent);

                await new Promise(resolve => setTimeout(resolve, 1000));

                agent.status = 'active';
                agent.task = this.getInitialTask(id);

                addChatMessage('agent', `ü§ñ Agent ${id} deployed: ${name}`);

                return agent;
            }

            getInitialTask(agentId) {
                const tasks = {
                    'ALPHA': 'Analyzing market patterns',
                    'BETA': 'Monitoring portfolio risk',
                    'GAMMA': 'System health monitoring'
                };
                return tasks[agentId] || 'General operations';
            }

            async executeAgent(agentId) {
                const agent = this.agents.get(agentId);
                if (!agent || agent.status === 'paused') return;

                const previousStatus = agent.status;
                agent.status = 'working';
                this.updateAgentUI();

                try {
                    await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));

                    const improvement = Math.random() * 0.1 - 0.05;
                    agent.performance = Math.max(-1, Math.min(1, agent.performance + improvement));
                    agent.lastUpdate = Date.now();

                    if (Math.abs(improvement) > 0.02) {
                        const sign = improvement > 0 ? '+' : '';
                        addChatMessage('agent', `ü§ñ ${agent.name}: Performance change: ${sign}${(improvement * 100).toFixed(1)}%`);
                    }

                    agent.status = previousStatus === 'learning' ? 'learning' : 'active';

                } catch (error) {
                    agent.status = 'error';
                    this.assignRepairTask(agentId, error.message);
                }

                this.updateAgentUI();
            }

            async assignRepairTask(agentId, issue) {
                const agent = this.agents.get(agentId);
                if (!agent) return;

                const repairTask = {
                    id: `repair_${Date.now()}`,
                    agentId: agentId,
                    issue: issue,
                    status: 'assigned',
                    steps: this.generateRepairSteps(issue),
                    currentStep: 0,
                    startTime: Date.now()
                };

                this.repairQueue.set(repairTask.id, repairTask);
                agent.status = 'repairing';
                agent.repairTasks.push(repairTask.id);

                addChatMessage('repair', `üöß MEN AT WORK: Repairing ${agent.name} - Issue: ${issue}`);
                notificationManager.show(`Agent ${agentId.toUpperCase()} under repair`, 'warning');

                await this.executeRepair(repairTask.id);
            }

            generateRepairSteps(issue) {
                return [
                    'Diagnosing issue',
                    'Isolating problem components',
                    'Applying corrective measures',
                    'Testing repairs',
                    'Validating functionality',
                    'Resuming operations'
                ];
            }

            async executeRepair(repairId) {
                const repairTask = this.repairQueue.get(repairId);
                if (!repairTask) return;

                for (let i = 0; i < repairTask.steps.length; i++) {
                    repairTask.currentStep = i;
                    repairTask.status = 'in_progress';

                    addChatMessage('repair', `üîß ${repairTask.agentId.toUpperCase()}: Step ${i + 1}/${repairTask.steps.length} - ${repairTask.steps[i]}`);

                    await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000));
                }

                const agent = this.agents.get(repairTask.agentId);
                if (agent) {
                    agent.status = 'active';
                    agent.repairTasks = agent.repairTasks.filter(id => id !== repairId);

                    addChatMessage('repair', `‚úÖ ${agent.name} repair completed successfully`);
                    notificationManager.show(`Agent ${repairTask.agentId.toUpperCase()} repair completed!`);
                }

                repairTask.status = 'completed';
                this.updateAgentUI();
            }

            updateAgentConfiguration(agentId, newConfig) {
                const agent = this.agents.get(agentId);
                if (!agent) return false;

                Object.assign(agent.configuration, newConfig);
                agent.lastUpdate = Date.now();

                addChatMessage('agent', `‚öôÔ∏è Configuration updated for ${agent.name}`);
                this.updateAgentUI();
                return true;
            }

            deleteAgent(agentId) {
                const agent = this.agents.get(agentId);
                if (!agent) return false;

                // Clean up any repair tasks
                agent.repairTasks.forEach(taskId => {
                    this.repairQueue.delete(taskId);
                });

                this.agents.delete(agentId);
                addChatMessage('agent', `üóëÔ∏è Agent deleted: ${agent.name}`);
                this.updateAgentUI();
                return true;
            }

            reassignAgent(agentId, newRole, newCapabilities) {
                const agent = this.agents.get(agentId);
                if (!agent) return false;

                agent.name = agent.name.split(' - ')[0] + ' - ' + newRole;
                agent.capabilities = newCapabilities;
                agent.task = `Reassigned to: ${newRole}`;
                agent.status = 'configuring';
                agent.lastUpdate = Date.now();

                setTimeout(() => {
                    agent.status = 'active';
                    this.updateAgentUI();
                }, 2000);

                addChatMessage('agent', `üîÑ Agent reassigned: ${agent.name}`);
                this.updateAgentUI();
                return true;
            }

            updateAgentUI() {
                const container = document.getElementById('agents-content');
                if (!container) return;

                if (this.agents.size === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">üîÑ Initializing agent system...</div>';
                    return;
                }

                container.innerHTML = Array.from(this.agents.values()).map(agent => `
                    <div class="agent-card">
                        <div class="agent-status">
                            <div class="status-dot ${agent.status}"></div>
                            <strong>${agent.name}</strong>
                        </div>
                        <div style="font-size: 11px;">
                            Task: ${agent.task}<br>
                            Performance: ${agent.performance > 0 ? '+' : ''}${(agent.performance * 100).toFixed(1)}%<br>
                            Status: ${this.getStatusText(agent.status)}
                            ${agent.repairTasks.length > 0 ? `<br><span style="color: #ff6600;">üöß Repairs: ${agent.repairTasks.length}</span>` : ''}
                        </div>
                        <div style="margin-top: 8px;">
                            <button onclick="configureAgent('${agent.id}')" style="font-size: 10px;">‚öôÔ∏è Configure</button>
                            <button onclick="pauseAgent('${agent.id}')" style="font-size: 10px;">${agent.status === 'paused' ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'} ${agent.status === 'paused' ? 'Resume' : 'Pause'}</button>
                            ${STATE.user.accessLevel === 'superadmin' ? `<button onclick="deleteAgent('${agent.id}')" style="font-size: 10px;" class="danger">üóëÔ∏è</button>` : ''}
                        </div>
                        ${this.getRepairStatus(agent)}
                    </div>
                `).join('') + `
                    <div style="margin-top: 15px;">
                        <button onclick="createNewAgent()" style="width: 100%; margin: 5px 0;" class="primary">‚ûï Create New Agent</button>
                        <button onclick="viewAgentLogs()" style="width: 100%; margin: 5px 0;">üìã View Logs</button>
                        ${STATE.user.accessLevel === 'superadmin' ? '<button onclick="openAgentConfiguration()" style="width: 100%; margin: 5px 0;" class="admin">‚öôÔ∏è Agent Management</button>' : ''}
                    </div>
                `;

                // Update active agents count
                document.getElementById('active-agents').textContent = Array.from(this.agents.values()).filter(a => a.status === 'active').length;

                // Update admin panel stats if visible
                if (document.getElementById('admin-panel').style.display !== 'none') {
                    document.getElementById('admin-active-agents').textContent = this.agents.size;
                    const avgPerformance = Array.from(this.agents.values()).reduce((sum, agent) => sum + agent.performance, 0) / this.agents.size;
                    document.getElementById('admin-avg-performance').textContent = ((avgPerformance || 0) * 100).toFixed(1) + '%';
                    const issues = Array.from(this.agents.values()).filter(a => a.status === 'error' || a.repairTasks.length > 0).length;
                    document.getElementById('admin-issues').textContent = issues;
                }
            }

            getStatusText(status) {
                const statusMap = {
                    'active': 'Active and operational',
                    'working': 'Processing tasks',
                    'learning': 'Learning from data',
                    'paused': 'Temporarily paused',
                    'repairing': 'Under repair',
                    'configuring': 'Being configured',
                    'error': 'Error state'
                };
                return statusMap[status] || 'Unknown status';
            }

            getRepairStatus(agent) {
                if (agent.repairTasks.length === 0) return '';

                const activeRepair = this.repairQueue.get(agent.repairTasks[0]);
                if (!activeRepair) return '';

                return `
                    <div class="repair-status">
                        <strong>üîß Repair Status:</strong><br>
                        Step ${activeRepair.currentStep + 1}/${activeRepair.steps.length}: ${activeRepair.steps[activeRepair.currentStep]}<br>
                        <div class="progress-bar" style="margin-top: 5px;">
                            <div class="progress-fill" style="width: ${((activeRepair.currentStep + 1) / activeRepair.steps.length) * 100}%"></div>
                        </div>
                    </div>
                `;
            }
        }

        // Enhanced Wallet Management System
        class WalletManager {
            constructor() {
                this.providers = new Map();
                this.initializeProviders();
                this.eventHandlers = {
                    accountsChanged: this.handleAccountsChanged.bind(this),
                    chainChanged: this.handleChainChanged.bind(this)
                };
            }

            initializeProviders() {
                this.providers.set('metamask', {
                    name: 'MetaMask',
                    detect: () => typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask,
                    connect: this.connectMetaMask.bind(this)
                });

                this.providers.set('coinbase', {
                    name: 'Coinbase Wallet',
                    detect: () => typeof window.ethereum !== 'undefined' && window.ethereum.isCoinbaseWallet,
                    connect: this.connectCoinbaseWallet.bind(this)
                });
            }

            addMetaMaskListeners() {
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', this.eventHandlers.accountsChanged);
                    window.ethereum.on('chainChanged', this.eventHandlers.chainChanged);
                }
            }

            removeMetaMaskListeners() {
                if (window.ethereum) {
                    window.ethereum.removeListener('accountsChanged', this.eventHandlers.accountsChanged);
                    window.ethereum.removeListener('chainChanged', this.eventHandlers.chainChanged);
                }
            }

            async handleAccountsChanged(accounts) {
                if (accounts.length === 0) {
                    addChatMessage('wallet', 'MetaMask disconnected. Please connect again.');
                    notificationManager.show('MetaMask disconnected', 'warning');
                    // Find and remove all metamask/coinbase wallets
                    for (const [id, wallet] of STATE.wallets.entries()) {
                        if (wallet.type === 'metamask' || wallet.type === 'coinbase') {
                            this.disconnectWallet(id, true); // silent disconnect
                        }
                    }
                } else {
                    addChatMessage('wallet', `Account changed to: ${accounts[0].substring(0, 10)}...`);
                    notificationManager.show('MetaMask account changed', 'admin');

                    // Find the first metamask/coinbase wallet and update it
                    let walletFound = false;
                    for (const [id, wallet] of STATE.wallets.entries()) {
                        if ((wallet.type === 'metamask' || wallet.type === 'coinbase') && !walletFound) {
                            wallet.address = accounts[0];
                            wallet.balance = await this.getBalance(accounts[0]);
                            wallet.lastSync = Date.now();
                            walletFound = true;
                        } else if ((wallet.type === 'metamask' || wallet.type === 'coinbase') && walletFound) {
                            // If user has multiple metamask wallets connected, remove the others
                            STATE.wallets.delete(id);
                        }
                    }
                    updateWalletList();
                }
            }

            handleChainChanged(chainId) {
                addChatMessage('wallet', `Network changed to: ${chainId}`);
                notificationManager.show(`Switched to network ${chainId}`, 'admin');
                // Update chainId for all connected web3 wallets
                for (const wallet of STATE.wallets.values()) {
                    if (wallet.type === 'metamask' || wallet.type === 'coinbase') {
                        wallet.chainId = chainId;
                        this.syncWallet(wallet.id); // Re-sync balance on new chain
                    }
                }
                updateWalletList();
            }

            disconnectWallet(walletId, silent = false) {
                const wallet = STATE.wallets.get(walletId);
                if (wallet) {
                    STATE.wallets.delete(walletId);

                    // If this was the last web3 wallet, remove listeners
                    const remainingWeb3Wallets = Array.from(STATE.wallets.values()).some(w => w.type === 'metamask' || w.type === 'coinbase');
                    if (!remainingWeb3Wallets) {
                        this.removeMetaMaskListeners();
                    }

                    if (!silent) {
                        addChatMessage('wallet', `üîå Wallet disconnected: ${wallet.name}`);
                        notificationManager.show(`Wallet ${wallet.name} disconnected`);
                    }
                    updateWalletList();
                }
            }

            async connectMetaMask() {
                try {
                    if (!window.ethereum || !window.ethereum.isMetaMask) {
                        throw new Error('MetaMask not detected. Please install MetaMask extension.');
                    }

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (accounts.length === 0) {
                        throw new Error('No accounts available. Please unlock MetaMask.');
                    }

                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    const balance = await this.getBalance(accounts[0]);

                    return {
                        address: accounts[0],
                        balance: balance,
                        chainId: chainId,
                        type: 'metamask'
                    };
                } catch (error) {
                    throw new Error(`MetaMask connection failed: ${error.message}`);
                }
            }

            async connectCoinbaseWallet() {
                try {
                    if (!window.ethereum || !window.ethereum.isCoinbaseWallet) {
                        throw new Error('Coinbase Wallet not detected. Please install Coinbase Wallet.');
                    }

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (accounts.length === 0) {
                        throw new Error('No accounts available. Please unlock Coinbase Wallet.');
                    }

                    const balance = await this.getBalance(accounts[0]);

                    return {
                        address: accounts[0],
                        balance: balance,
                        type: 'coinbase'
                    };
                } catch (error) {
                    throw new Error(`Coinbase Wallet connection failed: ${error.message}`);
                }
            }

            async getBalance(address) {
                try {
                    const balance = await window.ethereum.request({
                        method: 'eth_getBalance',
                        params: [address, 'latest']
                    });

                    return parseFloat(parseInt(balance, 16) / Math.pow(10, 18));
                } catch (error) {
                    addChatMessage('wallet', `‚ö†Ô∏è Balance retrieval failed: ${error.message}`);
                    return 0;
                }
            }

            async syncWallet(walletId) {
                const wallet = STATE.wallets.get(walletId);
                if (!wallet) {
                    throw new Error('Wallet not found');
                }

                try {
                    notificationManager.show(`Syncing ${wallet.name}...`, 'admin', 2000);

                    if (wallet.type === 'metamask' || wallet.type === 'coinbase') {
                        const newBalance = await this.getBalance(wallet.address);
                        wallet.balance = newBalance;
                        wallet.lastSync = Date.now();

                        addChatMessage('wallet', `‚úÖ ${wallet.name} synced: ${newBalance.toFixed(4)} ETH`);
                        notificationManager.show(`${wallet.name} synced successfully!`);
                    } else {
                        throw new Error('Manual wallets cannot be synced automatically');
                    }

                    return wallet;
                } catch (error) {
                    const errorMsg = `Sync failed for ${wallet.name}: ${error.message}`;
                    addChatMessage('wallet', `‚ùå ${errorMsg}`);
                    notificationManager.show(errorMsg, 'error');

                    this.suggestSolution(wallet.type, error.message);
                    throw error;
                }
            }

            suggestSolution(walletType, errorMessage) {
                let suggestion = '';

                if (errorMessage.includes('not detected')) {
                    suggestion = `Please install ${walletType === 'metamask' ? 'MetaMask' : 'Coinbase Wallet'} browser extension`;
                } else if (errorMessage.includes('unlock')) {
                    suggestion = 'Please unlock your wallet and try again';
                } else if (errorMessage.includes('accounts')) {
                    suggestion = 'Please connect your wallet to this site';
                } else if (errorMessage.includes('network')) {
                    suggestion = 'Please check your network connection';
                } else {
                    suggestion = 'Please check wallet settings and try reconnecting';
                }

                notificationManager.show(`üí° Solution: ${suggestion}`, 'warning', 8000);
                addChatMessage('wallet', `üí° Suggested solution: ${suggestion}`);
            }
        }

        // Twitch Integration System
        class TwitchManager {
            constructor() {
                this.client = null;
                this.channel = '';
            }

            connect() {
                const channel = document.getElementById('twitch-channel').value.trim();
                const username = document.getElementById('twitch-username').value.trim();
                const token = document.getElementById('twitch-oauth').value.trim();

                if (!channel || !username || !token) {
                    notificationManager.show('Please fill in all Twitch credentials.', 'error');
                    return;
                }

                this.channel = channel;

                const options = {
                    options: { debug: true },
                    identity: {
                        username: username,
                        password: token
                    },
                    channels: [channel]
                };

                this.client = new tmi.client(options);

                this.client.on('message', this.onMessageHandler.bind(this));
                this.client.on('connected', this.onConnectedHandler.bind(this));
                this.client.on('disconnected', this.onDisconnectedHandler.bind(this));

                this.client.connect().catch(err => {
                    notificationManager.show(`Twitch connection error: ${err}`, 'error');
                    document.getElementById('twitch-status').textContent = 'Error';
                    document.getElementById('twitch-status').style.color = '#ff4444';
                });
            }

            disconnect() {
                if (this.client) {
                    this.client.disconnect();
                }
            }

            onConnectedHandler(addr, port) {
                notificationManager.show(`Connected to Twitch: ${addr}:${port}`, 'admin');
                document.getElementById('twitch-status').textContent = 'Connected';
                document.getElementById('twitch-status').style.color = '#00ff88';
                document.getElementById('twitch-connect-btn').disabled = true;
                document.getElementById('twitch-disconnect-btn').disabled = false;
                this.sendMessage(`METABOTPRIME v6.2 Connected!`);
            }

            onDisconnectedHandler(reason) {
                notificationManager.show(`Disconnected from Twitch: ${reason || 'Unknown reason'}`, 'warning');
                document.getElementById('twitch-status').textContent = 'Disconnected';
                document.getElementById('twitch-status').style.color = '#ff4444';
                document.getElementById('twitch-connect-btn').disabled = false;
                document.getElementById('twitch-disconnect-btn').disabled = true;
                this.client = null;
            }

            onMessageHandler(channel, userstate, message, self) {
                if (self) return;

                const chatLog = document.getElementById('twitch-chat-log');
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = `<span style="color: ${userstate.color || '#ffffff'}">${userstate['display-name']}:</span> ${message}`;
                chatLog.appendChild(messageDiv);
                chatLog.scrollTop = chatLog.scrollHeight;

                // Handle commands
                if (message.startsWith('!')) {
                    this.handleCommand(userstate, message);
                }
            }

            handleCommand(userstate, message) {
                const args = message.slice(1).split(' ');
                const command = args.shift().toLowerCase();

                const isMod = userstate.mod || userstate['user-type'] === 'mod';
                const isBroadcaster = userstate.badges && userstate.badges.broadcaster;
                const isVIP = userstate.badges && userstate.badges.vip;
                const hasPermission = isMod || isBroadcaster || isVIP;

                if (!hasPermission) {
                    this.sendMessage(`@${userstate['display-name']}, you do not have permission to use commands.`);
                    return;
                }

                switch (command) {
                    case 'autotrade':
                        if (args[0] === 'on') {
                            if (!STATE.trading.isAutoTrading) {
                                toggleAutonomousTrading();
                                this.sendMessage('ü§ñ Autonomous trading has been enabled.');
                            } else {
                                this.sendMessage('ü§ñ Autonomous trading is already active.');
                            }
                        } else if (args[0] === 'off') {
                            if (STATE.trading.isAutoTrading) {
                                toggleAutonomousTrading();
                                this.sendMessage('ü§ñ Autonomous trading has been disabled.');
                            } else {
                                this.sendMessage('ü§ñ Autonomous trading is already inactive.');
                            }
                        } else {
                            this.sendMessage('Usage: !autotrade <on|off>');
                        }
                        break;
                    case 'status':
                        const status = `
                            System: ${document.getElementById('system-status').textContent},
                            Capital: $${STATE.trading.capital.toFixed(2)},
                            Trades: ${STATE.trading.totalTrades},
                            Success: ${document.getElementById('success-rate').textContent}
                        `;
                        this.sendMessage(status.replace(/\s+/g, ' '));
                        break;
                    case 'report':
                        reportGenerator.generateSystemReport().then(report => {
                            const summary = `
                                Report: ${report.title} -
                                Health: ${report.data.systemHealth}%,
                                LLM: ${report.data.llmStatus},
                                Wallets: ${report.data.walletsConnected}
                            `;
                            this.sendMessage(summary.replace(/\s+/g, ' '));
                        });
                        break;
                    default:
                        this.sendMessage(`Unknown command: ${command}`);
                }
            }

            sendMessage(message) {
                if (this.client && this.client.readyState() === 'OPEN') {
                    this.client.say(this.channel, message);
                }
            }
        }

        // Enhanced Authentication System
        class AuthenticationSystem {
            constructor() {
                this.masterUsers = ['LeaderMasterShake'];
                this.sessionTimeout = 3600000; // 1 hour
                this.keyExpiry = 30 * 24 * 3600000; // 30 days
                this.pendingRequests = new Map();
            }

            async authenticateUser(username, password, accessLevel) {
                await new Promise(resolve => setTimeout(resolve, 1500));

                if (accessLevel === 'superadmin' && !this.masterUsers.includes(username)) {
                    throw new Error('Super Admin access restricted to authorized users only');
                }

                if (username === 'LeaderMasterShake' && password === 'MasterKey2024!') {
                    return {
                        username: username,
                        accessLevel: 'superadmin',
                        permissions: ['all'],
                        sessionId: this.generateSessionId(),
                        expires: Date.now() + this.sessionTimeout
                    };
                }

                if (password.length >= 8 && username.length >= 3) {
                    return {
                        username: username,
                        accessLevel: accessLevel,
                        permissions: this.getPermissions(accessLevel),
                        sessionId: this.generateSessionId(),
                        expires: Date.now() + this.sessionTimeout
                    };
                }

                throw new Error('Invalid credentials - minimum 3 chars username, 8 chars password');
            }

            generateSessionId() {
                return 'sess_' + Math.random().toString(36).substr(2, 16);
            }

            getPermissions(accessLevel) {
                const permissions = {
                    'user': ['trading', 'viewing'],
                    'admin': ['trading', 'viewing', 'user_management', 'system_config'],
                    'superadmin': ['all']
                };
                return permissions[accessLevel] || permissions['user'];
            }

            addAccessRequest(username, accessLevel) {
                const request = {
                    username: username,
                    accessLevel: accessLevel,
                    timestamp: Date.now(),
                    status: 'pending'
                };

                this.pendingRequests.set(username, request);
                return request;
            }

            getPendingRequests() {
                return Array.from(this.pendingRequests.values()).filter(r => r.status === 'pending');
            }
        }

        // Report Generation System
        class ReportGenerator {
            constructor() {
                this.reports = new Map();
            }

            async generateSystemReport() {
                const reportId = `report_${Date.now()}`;
                const report = {
                    id: reportId,
                    title: 'System Performance Report',
                    timestamp: new Date().toISOString(),
                    type: 'system',
                    data: await this.collectSystemData(),
                    status: 'generated'
                };

                this.reports.set(reportId, report);
                this.displayReport(report);
                return report;
            }

            async generateTradingReport() {
                const reportId = `report_${Date.now()}`;
                const report = {
                    id: reportId,
                    title: 'Trading Performance Report',
                    timestamp: new Date().toISOString(),
                    type: 'trading',
                    data: await this.collectTradingData(),
                    status: 'generated'
                };

                this.reports.set(reportId, report);
                this.displayReport(report);
                return report;
            }

            async generateAgentReport() {
                const reportId = `report_${Date.now()}`;
                const report = {
                    id: reportId,
                    title: 'Agent Performance Report',
                    timestamp: new Date().toISOString(),
                    type: 'agent',
                    data: await this.collectAgentData(),
                    status: 'generated'
                };

                this.reports.set(reportId, report);
                this.displayReport(report);
                return report;
            }

            async collectSystemData() {
                return {
                    uptime: document.getElementById('uptime').textContent,
                    systemLoad: document.getElementById('system-load').textContent,
                    networkHealth: document.getElementById('network-health').textContent,
                    securityLevel: document.getElementById('security-level').textContent,
                    databaseStatus: STATE.database.configured ? 'Connected' : 'Not Configured',
                    walletsConnected: STATE.wallets.size,
                    lastHealthCheck: STATE.system.lastHealthCheck || 'Never',
                    llmStatus: document.getElementById('llm-status').textContent
                };
            }

            async collectTradingData() {
                return {
                    currentCapital: STATE.trading.capital,
                    targetAmount: STATE.trading.target,
                    totalTrades: STATE.trading.totalTrades,
                    successfulTrades: STATE.trading.successfulTrades,
                    successRate: STATE.trading.totalTrades > 0 ?
                        ((STATE.trading.successfulTrades / STATE.trading.totalTrades) * 100).toFixed(2) + '%' : '0%',
                    isAutoTrading: STATE.trading.isAutoTrading,
                    riskLevel: document.getElementById('risk-level').value,
                    progressToTarget: ((STATE.trading.capital / STATE.trading.target) * 100).toFixed(2) + '%'
                };
            }

            async collectAgentData() {
                const agents = Array.from(agentSystem.agents.values());
                return {
                    totalAgents: agents.length,
                    activeAgents: agents.filter(a => a.status === 'active').length,
                    averagePerformance: agents.length > 0 ?
                        ((agents.reduce((sum, a) => sum + a.performance, 0) / agents.length) * 100).toFixed(2) + '%' : '0%',
                    agentsUnderRepair: agents.filter(a => a.repairTasks.length > 0).length,
                    agentDetails: agents.map(a => ({
                        name: a.name,
                        status: a.status,
                        performance: (a.performance * 100).toFixed(2) + '%',
                        capabilities: a.capabilities.join(', '),
                        lastUpdate: new Date(a.lastUpdate).toLocaleString()
                    }))
                };
            }

            displayReport(report) {
                document.getElementById('report-panel').style.display = 'block';
                const container = document.getElementById('report-content');

                let html = `
                    <div class="report-section">
                        <h3>${report.title}</h3>
                        <p>Generated: ${new Date(report.timestamp).toLocaleString()}</p>
                    </div>
                `;

                if (report.type === 'system') {
                    html += this.formatSystemReport(report.data);
                } else if (report.type === 'trading') {
                    html += this.formatTradingReport(report.data);
                } else if (report.type === 'agent') {
                    html += this.formatAgentReport(report.data);
                }

                html += `
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="acknowledgeReport('${report.id}')" class="primary">‚úÖ Acknowledge Report</button>
                        <button onclick="exportReport('${report.id}')" class="admin">üì§ Export Report</button>
                    </div>
                `;

                container.innerHTML = html;
            }

            formatSystemReport(data) {
                return `
                    <div class="report-section">
                        <h4>üñ•Ô∏è System Status</h4>
                        <div class="report-metric"><span>Uptime</span><span>${data.uptime}</span></div>
                        <div class="report-metric"><span>System Load</span><span>${data.systemLoad}</span></div>
                        <div class="report-metric"><span>Network Health</span><span>${data.networkHealth}</span></div>
                        <div class="report-metric"><span>Security Level</span><span>${data.securityLevel}</span></div>
                        <div class="report-metric"><span>Database Status</span><span>${data.databaseStatus}</span></div>
                        <div class="report-metric"><span>Connected Wallets</span><span>${data.walletsConnected}</span></div>
                        <div class="report-metric"><span>LLM Status</span><span>${data.llmStatus}</span></div>
                    </div>
                `;
            }

            formatTradingReport(data) {
                return `
                    <div class="report-section">
                        <h4>üíπ Trading Performance</h4>
                        <div class="report-metric"><span>Current Capital</span><span>${data.currentCapital.toFixed(2)}</span></div>
                        <div class="report-metric"><span>Target Amount</span><span>${data.targetAmount.toFixed(2)}</span></div>
                        <div class="report-metric"><span>Progress to Target</span><span>${data.progressToTarget}</span></div>
                        <div class="report-metric"><span>Total Trades</span><span>${data.totalTrades}</span></div>
                        <div class="report-metric"><span>Successful Trades</span><span>${data.successfulTrades}</span></div>
                        <div class="report-metric"><span>Success Rate</span><span>${data.successRate}</span></div>
                        <div class="report-metric"><span>Auto Trading</span><span>${data.isAutoTrading ? 'Active' : 'Inactive'}</span></div>
                        <div class="report-metric"><span>Risk Level</span><span>${data.riskLevel}</span></div>
                    </div>
                `;
            }

            formatAgentReport(data) {
                let html = `
                    <div class="report-section">
                        <h4>ü§ñ Agent Performance</h4>
                        <div class="report-metric"><span>Total Agents</span><span>${data.totalAgents}</span></div>
                        <div class="report-metric"><span>Active Agents</span><span>${data.activeAgents}</span></div>
                        <div class="report-metric"><span>Average Performance</span><span>${data.averagePerformance}</span></div>
                        <div class="report-metric"><span>Agents Under Repair</span><span>${data.agentsUnderRepair}</span></div>
                    </div>
                `;

                if (data.agentDetails.length > 0) {
                    html += `
                        <div class="report-section">
                            <h4>üìã Individual Agent Details</h4>
                            ${data.agentDetails.map(agent => `
                                <div style="background: rgba(0,0,0,0.3); padding: 10px; margin: 5px 0; border-radius: 4px;">
                                    <strong>${agent.name}</strong><br>
                                    Status: ${agent.status} | Performance: ${agent.performance}<br>
                                    Capabilities: ${agent.capabilities}<br>
                                    Last Update: ${agent.lastUpdate}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                return html;
            }
        }

        // Global instances
        let dbManager, agentSystem, authSystem, notificationManager, walletManager, llmSystem, reportGenerator, twitchManager;
        let particles = [];
        let startTime = Date.now();
        let dragElement = null;
        let dragOffset = { x: 0, y: 0 };

        // Initialization Functions
        async function initializeSystem() {
            // Initialize core systems
            notificationManager = new NotificationManager();
            authSystem = new AuthenticationSystem();
            dbManager = new DatabaseManager();
            walletManager = new WalletManager();
            agentSystem = new MultiAgentSystem();
            llmSystem = new LLMIntegration();
            reportGenerator = new ReportGenerator();
            twitchManager = new TwitchManager();

            // Initialize UI elements
            initializeParticles();
            setupEventListeners();
            makePanelsDraggable();

            // Show database configuration wizard
            showDatabaseWizard();

            STATE.system.initialized = true;
            console.log('ü§ñ METABOTPRIME Enhanced v6.2 initialized');
        }

        function showDatabaseWizard() {
            document.getElementById('db-wizard').style.display = 'block';
            document.getElementById('db-status-section').style.display = 'none';
        }

        // Database Configuration Functions
        function selectDatabaseType() {
            const dbType = document.getElementById('db-type-select').value;
            if (!dbType) return;

            const configHtml = {
                'mongodb': `
                    <label>Connection String:</label>
                    <input type="text" id="db-connection-string" placeholder="mongodb://localhost:27017/metabotprime" value="mongodb://localhost:27017/metabotprime">
                    <small>Default local MongoDB connection</small>
                `,
                'postgresql': `
                    <label>Host:</label>
                    <input type="text" id="db-host" placeholder="localhost" value="localhost">
                    <label>Port:</label>
                    <input type="number" id="db-port" placeholder="5432" value="5432">
                    <label>Database:</label>
                    <input type="text" id="db-name" placeholder="metabotprime" value="metabotprime">
                    <label>Username:</label>
                    <input type="text" id="db-user" placeholder="username">
                    <label>Password:</label>
                    <input type="password" id="db-password" placeholder="password">
                `,
                'mysql': `
                    <label>Host:</label>
                    <input type="text" id="db-host" placeholder="localhost" value="localhost">
                    <label>Port:</label>
                    <input type="number" id="db-port" placeholder="3306" value="3306">
                    <label>Database:</label>
                    <input type="text" id="db-name" placeholder="metabotprime" value="metabotprime">
                    <label>Username:</label>
                    <input type="text" id="db-user" placeholder="username">
                    <label>Password:</label>
                    <input type="password" id="db-password" placeholder="password">
                `
            };

            document.getElementById('connection-config').innerHTML = configHtml[dbType];
            showWizardStep(2);
        }

        async function testDatabaseConnection() {
            const dbType = document.getElementById('db-type-select').value;
            let config = {};

            if (dbType === 'mongodb') {
                config.connectionString = document.getElementById('db-connection-string').value;
            } else {
                config = {
                    host: document.getElementById('db-host').value,
                    port: parseInt(document.getElementById('db-port').value),
                    database: document.getElementById('db-name').value,
                    user: document.getElementById('db-user').value,
                    password: document.getElementById('db-password').value
                };
            }

            const success = await dbManager.configureDatabase(dbType, config);
            if (success) {
                showWizardStep(3);
            }
        }

        async function llmConfigureDatabase() {
            const dbType = document.getElementById('db-type-select').value || 'mongodb';
            await llmSystem.processRequest('configure_database', { dbType: dbType }, 'high');
        }

        function completeDatabaseSetup() {
            document.getElementById('db-wizard').style.display = 'none';
            document.getElementById('db-status-section').style.display = 'block';

            // Enable trading system now that database is ready
            enableTradingSystem();
        }

        function showWizardStep(step) {
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                el.classList.toggle('active', index === step - 1);
            });
        }

        function enableTradingSystem() {
            document.getElementById('auto-trade-btn').disabled = false;
            document.getElementById('auto-trade-btn').textContent = '‚ñ∂Ô∏è Start Auto-Trading';

            // Initialize with small starting capital for demo
            STATE.trading.capital = 10.00;
            STATE.trading.initialized = true;
            updateTradingUI();

            addChatMessage('trading', '‚úÖ Trading system ready - Demo mode with $10.00 starting capital');
        }

        // Authentication Functions
        async function attemptLogin() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const accessLevel = document.getElementById('access-level').value;

            if (!username || !password) {
                notificationManager.show('Please enter username and password', 'error');
                return;
            }

            try {
                notificationManager.show('Authenticating...', 'admin', 3000);
                const user = await authSystem.authenticateUser(username, password, accessLevel);

                STATE.user = {
                    ...user,
                    isLoggedIn: true
                };

                // Hide login screen and show interface
                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('menu-bar').style.display = 'flex';
                document.getElementById('user-display').textContent = `${username} (${accessLevel})`;

                // Show admin menu if applicable
                if (accessLevel === 'admin' || accessLevel === 'superadmin') {
                    document.getElementById('admin-menu').style.display = 'block';
                }

                notificationManager.show(`Welcome ${username}!`, 'admin');
                addChatMessage('system', `üîê User logged in: ${username} (${accessLevel})`);

                // Initialize agent system after login
                if (!agentSystem.initialized) {
                    await agentSystem.initialize();
                }

            } catch (error) {
                notificationManager.show(error.message, 'error');
            }
        }

        function requestAccess() {
            const username = document.getElementById('username').value.trim();
            const accessLevel = document.getElementById('access-level').value;

            if (!username) {
                notificationManager.show('Please enter a username', 'error');
                return;
            }

            const request = authSystem.addAccessRequest(username, accessLevel);
            notificationManager.show('Access request submitted for review', 'admin');
            addChatMessage('system', `üìù Access request from: ${username} (${accessLevel})`);

            // Update admin panel if super admin is logged in
            if (STATE.user.accessLevel === 'superadmin') {
                updateUserRequests();
            }
        }

        function logout() {
            STATE.user.isLoggedIn = false;
            STATE.user = { username: '', accessLevel: 'user', isLoggedIn: false, permissions: [] };

            document.getElementById('login-screen').style.display = 'flex';
            document.getElementById('menu-bar').style.display = 'none';
            document.getElementById('admin-menu').style.display = 'none';

            // Reset system states
            if (STATE.trading.isAutoTrading) {
                emergencyStop();
            }

            closeAllPanels();
            notificationManager.show('Logged out successfully');
        }

        // Panel Management Functions
        function makePanelsDraggable() {
            document.querySelectorAll('.draggable-panel').forEach(panel => {
                makeDraggable(panel);
            });
        }

        function makeDraggable(element) {
            const header = element.querySelector('.panel-header');

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('panel-btn')) return;

                dragElement = element;
                const rect = element.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;

                element.style.zIndex = 1000;
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);

                e.preventDefault();
            });
        }

        function drag(e) {
            if (!dragElement) return;

            const newX = e.clientX - dragOffset.x;
            const newY = e.clientY - dragOffset.y;

            dragElement.style.left = Math.max(0, Math.min(newX, window.innerWidth - dragElement.offsetWidth)) + 'px';
            dragElement.style.top = Math.max(35, Math.min(newY, window.innerHeight - dragElement.offsetHeight)) + 'px';
        }

        function stopDrag() {
            if (dragElement) {
                dragElement.style.zIndex = 2;
                dragElement = null;
            }
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                STATE.panels.minimized.delete(panelId);
            } else {
                panel.style.display = 'none';
                STATE.panels.minimized.add(panelId);
            }
        }

        function minimizePanel(panelId) {
            const panel = document.getElementById(panelId);
            const content = panel.querySelector('.panel-content');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                STATE.panels.minimized.delete(panelId);
            } else {
                content.style.display = 'none';
                STATE.panels.minimized.add(panelId);
            }
        }

        function maximizePanel(panelId) {
            const panel = document.getElementById(panelId);

            if (panel.style.width === '95vw') {
                // Restore original size
                panel.style.width = '';
                panel.style.height = '';
                panel.style.top = '';
                panel.style.left = '';
                panel.style.right = '';
            } else {
                // Maximize
                panel.style.width = '95vw';
                panel.style.height = '90vh';
                panel.style.top = '40px';
                panel.style.left = '2.5vw';
                panel.style.right = 'auto';
            }
        }

        function closePanel(panelId) {
            document.getElementById(panelId).style.display = 'none';
        }

        function closeAdminPanel() {
            document.getElementById('admin-panel').style.display = 'none';
        }

        function closeAllPanels() {
            document.querySelectorAll('.draggable-panel').forEach(panel => {
                panel.style.display = 'none';
            });
        }

        // Report Functions
        function openReportPanel() {
            document.getElementById('report-panel').style.display = 'block';
        }

        async function generateSystemReport() {
            notificationManager.show('Generating system report...', 'admin', 2000);
            await reportGenerator.generateSystemReport();
        }

        async function generateTradingReport() {
            notificationManager.show('Generating trading report...', 'admin', 2000);
            await reportGenerator.generateTradingReport();
        }

        async function generateAgentReport() {
            notificationManager.show('Generating agent report...', 'admin', 2000);
            await reportGenerator.generateAgentReport();
        }

        function acknowledgeReport(reportId) {
            const report = reportGenerator.reports.get(reportId);
            if (report) {
                report.acknowledged = true;
                report.acknowledgedBy = STATE.user.username;
                report.acknowledgedAt = new Date().toISOString();

                notificationManager.show('Report acknowledged', 'admin');
                addChatMessage('report', `üìã Report acknowledged: ${report.title}`);
            }
        }

        function exportReport(reportId) {
            const report = reportGenerator.reports.get(reportId);
            if (report) {
                const dataStr = JSON.stringify(report, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});

                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${report.type}_report_${new Date().toISOString().split('T')[0]}.json`;
                link.click();

                addChatMessage('report', `üì§ Report exported: ${report.title}`);
                notificationManager.show('Report exported successfully');
            }
        }

        // LLM Functions
        async function llmDiagnose() {
            notificationManager.show('LLM performing system diagnosis...', 'llm', 3000);
            const requestId = await llmSystem.processRequest('diagnose_system', {}, 'high');
        }

        async function llmOptimizeAgents() {
            if (STATE.user.accessLevel !== 'superadmin') {
                notificationManager.show('Super Admin access required', 'error');
                return;
            }

            notificationManager.show('LLM optimizing agents...', 'llm', 3000);
            await llmSystem.processRequest('optimize_agents', {}, 'high');
        }

        async function llmConfigureWallet() {
            const walletName = document.getElementById('wallet-name').value.trim();
            if (!walletName) {
                notificationManager.show('Please enter wallet name', 'error');
                return;
            }

            notificationManager.show('LLM configuring wallet...', 'llm', 3000);
            await llmSystem.processRequest('configure_wallet', { name: walletName }, 'high');
        }

        async function llmOptimizeNodes() {
            notificationManager.show('LLM optimizing nodes...', 'llm', 3000);
            await llmSystem.processRequest('optimize_nodes', {}, 'normal');
        }

        // Agent Configuration Functions
        function openAgentConfiguration() {
            if (STATE.user.accessLevel !== 'superadmin') {
                notificationManager.show('Super Admin access required', 'error');
                return;
            }

            document.getElementById('agent-config-modal').style.display = 'flex';
            updateAgentConfigList();
        }

        function updateAgentConfigList() {
            const container = document.getElementById('agent-config-list');
            if (agentSystem.agents.size === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No agents available for configuration</div>';
                return;
            }

            container.innerHTML = Array.from(agentSystem.agents.values()).map(agent => `
                <div class="agent-config-card">
                    <h4>${agent.name}</h4>
                    <div style="margin: 10px 0;">
                        <label>Priority:</label>
                        <select id="priority-${agent.id}" onchange="updateAgentConfig('${agent.id}')">
                            <option value="low" ${agent.configuration.priority === 'low' ? 'selected' : ''}>Low</option>
                            <option value="normal" ${agent.configuration.priority === 'normal' ? 'selected' : ''}>Normal</option>
                            <option value="high" ${agent.configuration.priority === 'high' ? 'selected' : ''}>High</option>
                            <option value="critical" ${agent.configuration.priority === 'critical' ? 'selected' : ''}>Critical</option>
                        </select>
                    </div>
                    <div style="margin: 10px 0;">
                        <label>Max Tasks:</label>
                        <input type="number" id="maxtasks-${agent.id}" value="${agent.configuration.maxTasks}" min="1" max="50" onchange="updateAgentConfig('${agent.id}')">
                    </div>
                    <div style="margin: 10px 0;">
                        <label>Timeout (ms):</label>
                        <input type="number" id="timeout-${agent.id}" value="${agent.configuration.timeout}" min="1000" max="120000" step="1000" onchange="updateAgentConfig('${agent.id}')">
                    </div>
                    <div style="margin: 10px 0;">
                        <label>Capabilities:</label>
                        <input type="text" id="capabilities-${agent.id}" value="${agent.capabilities.join(', ')}" onchange="updateAgentCapabilities('${agent.id}')">
                    </div>
                    <div style="margin: 10px 0;">
                        <button onclick="reassignAgentRole('${agent.id}')" class="warning">üîÑ Reassign Role</button>
                        <button onclick="deleteAgentFromConfig('${agent.id}')" class="danger">üóëÔ∏è Delete Agent</button>
                    </div>
                </div>
            `).join('');
        }

        function updateAgentConfig(agentId) {
            const priority = document.getElementById(`priority-${agentId}`).value;
            const maxTasks = parseInt(document.getElementById(`maxtasks-${agentId}`).value);
            const timeout = parseInt(document.getElementById(`timeout-${agentId}`).value);

            const newConfig = {
                priority: priority,
                maxTasks: maxTasks,
                timeout: timeout
            };

            if (agentSystem.updateAgentConfiguration(agentId, newConfig)) {
                notificationManager.show(`Agent ${agentId.toUpperCase()} configuration updated`, 'admin');
            }
        }

        function updateAgentCapabilities(agentId) {
            const capabilitiesStr = document.getElementById(`capabilities-${agentId}`).value;
            const capabilities = capabilitiesStr.split(',').map(c => c.trim()).filter(c => c.length > 0);

            const agent = agentSystem.agents.get(agentId);
            if (agent) {
                agent.capabilities = capabilities;
                addChatMessage('agent', `üîß Updated capabilities for ${agent.name}: ${capabilities.join(', ')}`);
                notificationManager.show(`Agent capabilities updated`, 'admin');
            }
        }

        function reassignAgentRole(agentId) {
            const newRole = prompt('Enter new role for agent (e.g., "Market Scanner"):');
            if (!newRole || !newRole.trim()) return;

            const newCapabilities = prompt('Enter new capabilities (comma-separated):');
            if (!newCapabilities || !newCapabilities.trim()) return;

            const capabilities = newCapabilities.split(',').map(c => c.trim()).filter(c => c.length > 0);

            if (agentSystem.reassignAgent(agentId, newRole.trim(), capabilities)) {
                notificationManager.show(`Agent ${agentId.toUpperCase()} reassigned successfully`, 'admin');
                updateAgentConfigList();
            }
        }

        function deleteAgentFromConfig(agentId) {
            if (confirm(`Are you sure you want to delete agent ${agentId.toUpperCase()}?`)) {
                if (agentSystem.deleteAgent(agentId)) {
                    notificationManager.show(`Agent ${agentId.toUpperCase()} deleted`, 'admin');
                    updateAgentConfigList();
                }
            }
        }

        function createAgentFromConfig() {
            const name = document.getElementById('new-agent-name').value.trim();
            const type = document.getElementById('new-agent-type').value;
            const capabilitiesStr = document.getElementById('new-agent-capabilities').value.trim();

            if (!name || !type) {
                notificationManager.show('Please enter agent name and select type', 'error');
                return;
            }

            let capabilities = [];
            if (capabilitiesStr) {
                capabilities = capabilitiesStr.split(',').map(c => c.trim()).filter(c => c.length > 0);
            } else {
                // Default capabilities based on type
                const defaultCapabilities = {
                    'trading': ['market_analysis', 'trade_execution', 'risk_management'],
                    'analysis': ['data_analysis', 'pattern_recognition', 'reporting'],
                    'monitoring': ['system_monitoring', 'health_checks', 'alerting'],
                    'research': ['market_research', 'trend_analysis', 'forecasting'],
                    'custom': ['general_purpose']
                };
                capabilities = defaultCapabilities[type] || ['general_purpose'];
            }

            const agentId = `${type.toUpperCase()}_${Date.now()}`;
            agentSystem.createAgent(agentId, name, capabilities).then(() => {
                notificationManager.show(`Agent "${name}" created successfully!`, 'admin');
                updateAgentConfigList();

                // Reset form
                document.getElementById('new-agent-name').value = '';
                document.getElementById('new-agent-type').value = 'trading';
                document.getElementById('new-agent-capabilities').value = '';
            });
        }

        // Trading Functions
        function toggleAutonomousTrading() {
            if (!STATE.trading.initialized) {
                notificationManager.show('Trading system not initialized', 'error');
                return;
            }

            STATE.trading.isAutoTrading = !STATE.trading.isAutoTrading;
            const btn = document.getElementById('auto-trade-btn');

            if (STATE.trading.isAutoTrading) {
                btn.innerHTML = '‚è∏Ô∏è Pause Auto-Trading';
                btn.className = 'danger';
                addChatMessage('trading', 'ü§ñ Autonomous trading started');
                startTradingLoop();
            } else {
                btn.innerHTML = '‚ñ∂Ô∏è Start Auto-Trading';
                btn.className = 'primary';
                addChatMessage('trading', '‚è∏Ô∏è Autonomous trading paused');
            }
        }

        function emergencyStop() {
            STATE.trading.isAutoTrading = false;
            document.getElementById('auto-trade-btn').innerHTML = '‚ñ∂Ô∏è Start Auto-Trading';
            document.getElementById('auto-trade-btn').className = 'primary';

            addChatMessage('emergency', 'üõë EMERGENCY STOP - All trading halted');
            notificationManager.show('Emergency stop activated!', 'error');
        }

        function updateRiskLevel() {
            const riskLevel = document.getElementById('risk-level').value;
            addChatMessage('trading', `‚öñÔ∏è Risk level updated: ${riskLevel}`);
        }

        function startTradingLoop() {
            if (!STATE.trading.isAutoTrading) return;

            const interval = setInterval(() => {
                if (!STATE.trading.isAutoTrading) {
                    clearInterval(interval);
                    return;
                }

                // Simulate trading with realistic probability
                if (Math.random() < 0.15) { // 15% chance of trade per cycle
                    simulateTrade();
                }

                updateTradingUI();
            }, 8000); // Every 8 seconds
        }

        function simulateTrade() {
            const strategies = ['Momentum', 'Scalping', 'DCA', 'Grid', 'Arbitrage'];
            const strategy = strategies[Math.floor(Math.random() * strategies.length)];
            const success = Math.random() < 0.68; // 68% success rate

            const amount = Math.min(STATE.trading.capital * 0.1, Math.random() * 5 + 1); // Max 10% of capital or $5
            const profitRate = success ?
                Math.random() * 0.08 + 0.02 : // 2-10% profit
                -(Math.random() * 0.05 + 0.01); // 1-6% loss

            const profit = amount * profitRate;

            STATE.trading.totalTrades++;
            if (success) STATE.trading.successfulTrades++;
            STATE.trading.capital = Math.max(0.01, STATE.trading.capital + profit);

            // Add to recent trades display
            updateRecentTrades(strategy, success, profit, amount);

            if (profit > 0.5 || profit < -0.3) {
                addChatMessage('trading', `${success ? 'üíπ' : 'üìâ'} ${strategy}: ${profit > 0 ? '+' : ''}${profit.toFixed(2)}`);
            }
        }

        function updateRecentTrades(strategy, success, profit, amount) {
            const tradeLog = document.getElementById('recent-trades');
            const logEntry = document.createElement('div');
            logEntry.style.marginBottom = '3px';
            logEntry.style.padding = '4px';
            logEntry.style.background = success ? 'rgba(0,255,136,0.1)' : 'rgba(255,68,68,0.1)';
            logEntry.style.borderRadius = '3px';
            logEntry.style.fontSize = '10px';
            logEntry.innerHTML = `
                <span style="color: ${success ? '#00ff88' : '#ff4444'};">
                    ${new Date().toLocaleTimeString()} - ${strategy}
                </span><br>
                Size: ${amount.toFixed(2)} | ${success ? 'PROFIT' : 'LOSS'}: ${profit > 0 ? '+' : ''}${profit.toFixed(2)}
            `;

            if (tradeLog.children.length > 6) {
                tradeLog.removeChild(tradeLog.lastChild);
            }

            // Remove placeholder text
            const placeholder = tradeLog.querySelector('div[style*="text-align: center"]');
            if (placeholder) tradeLog.removeChild(placeholder);

            tradeLog.insertBefore(logEntry, tradeLog.firstChild);
        }

        function updateTradingUI() {
            document.getElementById('current-capital').textContent = STATE.trading.capital.toFixed(2);
            document.getElementById('trading-balance').textContent = STATE.trading.capital.toFixed(2);
            document.getElementById('holding-balance').textContent = STATE.trading.holdingBalance.toFixed(2);
            document.getElementById('total-trades').textContent = STATE.trading.totalTrades;

            const successRate = STATE.trading.totalTrades > 0 ?
                ((STATE.trading.successfulTrades / STATE.trading.totalTrades) * 100).toFixed(1) + '%' : '0%';
            document.getElementById('success-rate').textContent = successRate;

            const progressPercent = ((STATE.trading.capital / STATE.trading.target) * 100).toFixed(1) + '%';
            document.getElementById('progress-percent').textContent = progressPercent;
        }

        // Database Functions
        async function createManualBackup() {
            if (dbManager) {
                await dbManager.createBackup('manual');
            }
        }

        async function analyzeHistoricalData() {
            if (dbManager && dbManager.isConfigured) {
                notificationManager.show('Analyzing historical data...', 'admin', 3000);
                setTimeout(() => {
                    addChatMessage('database', 'üìä Historical analysis completed - 3 profitable patterns identified');
                    notificationManager.show('Historical analysis complete!');
                }, 4000);
            }
        }

        function optimizeStrategies() {
            notificationManager.show('Optimizing trading strategies...', 'admin', 3000);
            setTimeout(() => {
                addChatMessage('database', '‚ö° Strategy optimization completed - Expected 12% performance improvement');
                notificationManager.show('Strategy optimization complete!');
            }, 3000);
        }

        function exportData() {
            if (dbManager && dbManager.isConfigured) {
                notificationManager.show('Exporting trading data...', 'admin', 2000);
                setTimeout(() => {
                    addChatMessage('database', 'üì§ Data export completed - metabotprime_export.json created');
                    notificationManager.show('Data export complete!');
                }, 2000);
            }
        }

        // Agent Functions
        function configureAgent(agentId) {
            if (STATE.user.accessLevel === 'superadmin') {
                openAgentConfiguration();
            } else {
                const agent = agentSystem.agents.get(agentId);
                if (agent) {
                    addChatMessage('agent', `‚öôÔ∏è Agent configuration requires Super Admin access`);
                    notificationManager.show(`Agent configuration locked - Super Admin required`, 'warning');
                }
            }
        }

        function pauseAgent(agentId) {
            const agent = agentSystem.agents.get(agentId);
            if (agent) {
                agent.status = agent.status === 'paused' ? 'active' : 'paused';
                addChatMessage('agent', `${agent.status === 'paused' ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'} ${agent.name} ${agent.status}`);
                agentSystem.updateAgentUI();
            }
        }

        function deleteAgent(agentId) {
            if (STATE.user.accessLevel !== 'superadmin') {
                notificationManager.show('Super Admin access required', 'error');
                return;
            }

            if (confirm(`Delete agent ${agentId.toUpperCase()}? This action cannot be undone.`)) {
                if (agentSystem.deleteAgent(agentId)) {
                    notificationManager.show(`Agent ${agentId.toUpperCase()} deleted`, 'admin');
                }
            }
        }

        function createNewAgent() {
            const name = prompt('Enter new agent name (e.g., "Market Scanner"):');
            if (name && name.trim()) {
                const capabilities = ['general_purpose', 'data_analysis'];
                agentSystem.createAgent(`DELTA_${Date.now()}`, name.trim(), capabilities);
                notificationManager.show(`New agent "${name}" created!`);
            }
        }

        function viewAgentLogs() {
            notificationManager.show('Opening agent logs viewer...', 'admin');
            addChatMessage('agent', 'üìã Agent logs viewer opened - 24h activity summary available');
        }

        // Wallet Functions
        function openWalletManager() {
            document.getElementById('wallet-modal').style.display = 'flex';
            updateWalletList();
        }

        function handleWalletTypeChange() {
            const walletType = document.getElementById('wallet-type').value;
            const manualFields = document.getElementById('manual-wallet-fields');
            const addBtn = document.getElementById('add-wallet-btn');
            const llmBtn = document.getElementById('llm-wallet-btn');

            if (walletType === 'manual') {
                manualFields.style.display = 'block';
            } else {
                manualFields.style.display = 'none';
            }

            addBtn.disabled = !walletType;
            llmBtn.disabled = !walletType;
        }

        async function addWallet() {
            const type = document.getElementById('wallet-type').value;
            const name = document.getElementById('wallet-name').value.trim();

            if (!type || !name) {
                notificationManager.show('Please select wallet type and enter name', 'error');
                return;
            }

            try {
                let walletData = {
                    id: `wallet_${Date.now()}`,
                    name: name,
                    type: type,
                    balance: 0,
                    lastSync: Date.now()
                };

                if (type === 'metamask') {
                    try {
                        const connection = await walletManager.connectMetaMask();
                        walletData = { ...walletData, ...connection };
                    } catch (error) {
                        // Fallback to manual entry
                        addChatMessage('wallet', '‚ö†Ô∏è MetaMask auto-detect failed, creating manual entry');
                        notificationManager.show('MetaMask failed - created manual wallet entry', 'warning');

                        walletData.type = 'manual';
                        walletData.address = '0x' + Array(40).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('');
                        walletData.note = 'Auto-generated after MetaMask failure - Please update address';
                    }
                } else if (type === 'coinbase') {
                    try {
                        const connection = await walletManager.connectCoinbaseWallet();
                        walletData = { ...walletData, ...connection };
                    } catch (error) {
                        // Fallback to manual entry
                        addChatMessage('wallet', '‚ö†Ô∏è Coinbase Wallet auto-detect failed, creating manual entry');
                        notificationManager.show('Coinbase Wallet failed - created manual wallet entry', 'warning');

                        walletData.type = 'manual';
                        walletData.address = '0x' + Array(40).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('');
                        walletData.note = 'Auto-generated after Coinbase Wallet failure - Please update address';
                    }
                } else if (type === 'manual') {
                    const address = document.getElementById('wallet-address').value.trim();
                    if (!address) {
                        notificationManager.show('Please enter wallet address', 'error');
                        return;
                    }
                    walletData.address = address;
                    walletData.balance = 0;
                }

                STATE.wallets.set(walletData.id, walletData);
                updateWalletList();

                notificationManager.show(`Wallet "${name}" connected successfully!`);
                addChatMessage('wallet', `üíõ Connected wallet: ${name} (${walletData.type}) - ${walletData.address?.substring(0, 10)}...`);

                // Reset form
                document.getElementById('wallet-type').value = '';
                document.getElementById('wallet-name').value = '';
                document.getElementById('wallet-address').value = '';
                document.getElementById('add-wallet-btn').disabled = true;
                document.getElementById('llm-wallet-btn').disabled = true;
                handleWalletTypeChange();

            } catch (error) {
                notificationManager.show(error.message, 'error');
                addChatMessage('wallet', `‚ùå Wallet connection failed: ${error.message}`);
            }
        }

        async function syncWallet(walletId) {
            try {
                const updatedWallet = await walletManager.syncWallet(walletId);
                updateWalletList();
            } catch (error) {
                // Error already handled in walletManager.syncWallet
            }
        }

        function removeWallet(walletId) {
            const wallet = STATE.wallets.get(walletId);
            if (wallet && confirm(`Remove wallet "${wallet.name}"?`)) {
                STATE.wallets.delete(walletId);
                updateWalletList();
                addChatMessage('wallet', `‚ùå Removed wallet: ${wallet.name}`);
                notificationManager.show(`Wallet "${wallet.name}" removed`);
            }
        }

        function updateWalletList() {
            const container = document.getElementById('wallet-list');
            if (STATE.wallets.size === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No wallets connected</div>';
                return;
            }

            container.innerHTML = Array.from(STATE.wallets.entries()).map(([id, wallet]) => `
                <div class="wallet-card" style="margin: 10px 0; padding: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${wallet.name}</strong><br>
                            <small>${wallet.address ? wallet.address.substring(0, 20) + '...' : 'No address'}</small><br>
                            Balance: <span style="color: #00ff88;">${wallet.balance.toFixed(4)} ${wallet.type === 'manual' ? 'USD' : 'ETH'}</span><br>
                            <small>Last sync: ${new Date(wallet.lastSync).toLocaleString()}</small>
                            ${wallet.note ? `<br><small style="color: #ffaa00;">Note: ${wallet.note}</small>` : ''}
                        </div>
                        <div>
                            ${wallet.type !== 'manual' ? `<button onclick="syncWallet('${id}')" style="font-size: 10px;">üîÑ Sync</button>` : ''}
                            <button onclick="removeWallet('${id}')" style="font-size: 10px;">‚ùå</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Node Management Functions
        function openNodeManager() {
            document.getElementById('node-modal').style.display = 'flex';
            updateNodeStats();
        }

        function updateNodeStats() {
            // Simulate real-time node data
            const lanNodes = Math.floor(Math.random() * 3) + 2;
            const wanNodes = Math.floor(Math.random() * 5) + 10;
            const webNodes = Math.floor(Math.random() * 10) + 40;

            document.getElementById('lan-nodes').textContent = `${lanNodes} Active`;
            document.getElementById('wan-nodes').textContent = `${wanNodes} Active`;
            document.getElementById('web-nodes').textContent = `${webNodes} Active`;

            const latency = Math.floor(Math.random() * 20) + 15;
            const throughput = (Math.random() * 0.5 + 0.8).toFixed(1);

            document.getElementById('network-latency').textContent = `${latency}ms`;
            document.getElementById('network-throughput').textContent = `${throughput}GB/s`;

            // Update load distribution
            const tradingLoad = Math.floor(Math.random() * 20) + 35;
            const learningLoad = Math.floor(Math.random() * 15) + 25;
            const processingLoad = 100 - tradingLoad - learningLoad;

            document.getElementById('trading-load').textContent = tradingLoad;
            document.getElementById('learning-load').textContent = learningLoad;
            document.getElementById('processing-load').textContent = processingLoad;

            document.getElementById('trading-progress').style.width = tradingLoad + '%';
            document.getElementById('learning-progress-bar').style.width = learningLoad + '%';
            document.getElementById('processing-progress').style.width = processingLoad + '%';
        }

        function applyNodeConfig() {
            const priority = document.getElementById('node-priority').value;
            const distribution = document.getElementById('work-distribution').value;

            notificationManager.show('Applying node configuration...', 'admin', 2000);

            setTimeout(() => {
                addChatMessage('network', `üåê Node config applied: ${priority} priority, ${distribution} distribution`);
                notificationManager.show('Node configuration applied successfully!');
                updateNodeStats();
            }, 2000);
        }

        // Admin Functions
        function openAdminPanel() {
            if (STATE.user.accessLevel !== 'superadmin') {
                notificationManager.show('Super Admin access required', 'error');
                return;
            }

            document.getElementById('admin-panel').style.display = 'block';
            document.getElementById('admin-panel').style.zIndex = '1001';
            updateUserRequests();
        }

        function updateUserRequests() {
            const container = document.getElementById('user-requests');
            const requests = authSystem.getPendingRequests();

            if (requests.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">No pending requests</div>';
                return;
            }

            container.innerHTML = requests.map(request => `
                <div style="padding: 5px; border-bottom: 1px solid #333; font-size: 11px;">
                    <strong>${request.username}</strong> - ${request.accessLevel}<br>
                    <small>Requested: ${new Date(request.timestamp).toLocaleString()}</small>
                    <div style="float: right; margin-top: -25px;">
                        <button onclick="approveUser('${request.username}')" style="font-size: 10px; padding: 2px 6px;">‚úÖ</button>
                        <button onclick="denyUser('${request.username}')" style="font-size: 10px; padding: 2px 6px;">‚ùå</button>
                    </div>
                </div>
            `).join('');
        }

        function approveUser(username) {
            const request = authSystem.pendingRequests.get(username);
            if (request) {
                request.status = 'approved';
                notificationManager.show(`User ${username} approved`, 'admin');
                addChatMessage('admin', `‚úÖ Approved user: ${username} (${request.accessLevel})`);
                updateUserRequests();
            }
        }

        function denyUser(username) {
            const request = authSystem.pendingRequests.get(username);
            if (request) {
                request.status = 'denied';
                notificationManager.show(`User ${username} denied`, 'admin');
                addChatMessage('admin', `‚ùå Denied user: ${username}`);
                updateUserRequests();
            }
        }

        function refreshUserRequests() {
            updateUserRequests();
            notificationManager.show('User requests refreshed');
        }

        function generateNewKey() {
            const newKey = 'MBP_' + Math.random().toString(36).substr(2, 20).toUpperCase();
            document.getElementById('master-key').textContent = newKey.substr(0, 12) + '...';
            document.getElementById('key-expiry').textContent = '30 days';

            addChatMessage('security', `üîë New master key generated: ${newKey.substr(0, 8)}...`);
            notificationManager.show('New master key generated', 'admin');
        }

        function renewSubscriptions() {
            notificationManager.show('Renewing all subscriptions...', 'admin', 2000);
            setTimeout(() => {
                addChatMessage('admin', '‚ôªÔ∏è All subscriptions renewed successfully');
                notificationManager.show('Subscriptions renewed!', 'admin');
            }, 3000);
        }

        function optimizeNetwork() {
            notificationManager.show('Optimizing network performance...', 'admin', 2000);
            setTimeout(() => {
                addChatMessage('network', '‚ö° Network optimization completed - 15% performance improvement');
                notificationManager.show('Network optimized successfully!');
            }, 3000);
        }

        function distributeWork() {
            notificationManager.show('Distributing workload across nodes...', 'admin', 2000);
            setTimeout(() => {
                addChatMessage('network', 'üìã Workload distributed optimally across all nodes');
                notificationManager.show('Workload distribution complete!');
            }, 2500);
        }

        function viewNetworkHealth() {
            notificationManager.show('Generating network health report...', 'admin', 2000);
            setTimeout(() => {
                addChatMessage('network', 'üè• Network health: 98.7% - All systems operational');
                notificationManager.show('Network health report generated!');
            }, 2000);
        }

        function generateAnalyticsReport() {
            notificationManager.show('Generating comprehensive analytics report...', 'admin', 3000);
            setTimeout(() => {
                addChatMessage('admin', 'üìä Analytics report generated - Performance metrics, user activity, and system health included');
                notificationManager.show('Analytics report generated successfully!', 'admin');
            }, 4000);
        }

        // System Health Functions
        function performSystemHealthCheck() {
            notificationManager.show('Performing comprehensive system health check...', 'admin', 3000);

            setTimeout(() => {
                const health = Math.floor(Math.random() * 15) + 85; // 85-100%
                const issues = health < 95 ? Math.floor(Math.random() * 3) + 1 : 0;

                STATE.system.lastHealthCheck = Date.now();

                addChatMessage('system', `üè• Health check complete: ${health}% system health${issues > 0 ? ` - ${issues} minor issues detected` : ' - All systems optimal'}`);
                notificationManager.show(`System health: ${health}%${issues > 0 ? ' - Minor issues detected' : ' - Excellent!'}`, health < 90 ? 'warning' : 'success');

                // Auto-trigger LLM diagnosis if issues found
                if (issues > 0 && health < 90) {
                    setTimeout(() => {
                        addChatMessage('llm', 'üß† Auto-triggering LLM diagnosis due to detected issues...');
                        llmDiagnose();
                    }, 2000);
                }
            }, 4000);
        }

        function optimizeSystem() {
            notificationManager.show('Optimizing system performance...', 'admin', 3000);

            setTimeout(() => {
                const improvement = Math.floor(Math.random() * 12) + 8; // 8-20% improvement
                addChatMessage('system', `‚ö° System optimization complete: +${improvement}% performance boost`);
                notificationManager.show(`Performance improved by ${improvement}%!`, 'success');

                // Update system load display
                const newLoad = Math.max(5, parseInt(document.getElementById('system-load').textContent) - improvement);
                document.getElementById('system-load').textContent = newLoad + '%';
            }, 5000);
        }

        // Chat Functions
        function handleInput(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('user-input');
                const message = input.value.trim();
                if (message) {
                    addChatMessage('user', message);
                    processUserInput(message);
                    input.value = '';
                }
            }
        }

        async function processUserInput(message) {
            const lowerMessage = message.toLowerCase();

            setTimeout(async () => {
                if (lowerMessage.includes('llm') && (lowerMessage.includes('help') || lowerMessage.includes('assist'))) {
                    addChatMessage('llm', 'üß† LLM Assistant available. Try: "llm diagnose", "llm configure database", "llm optimize agents"');
                } else if (lowerMessage.includes('llm') && lowerMessage.includes('diagnose')) {
                    await llmDiagnose();
                } else if (lowerMessage.includes('llm') && lowerMessage.includes('configure') && lowerMessage.includes('database')) {
                    await llmConfigureDatabase();
                } else if (lowerMessage.includes('llm') && lowerMessage.includes('optimize') && lowerMessage.includes('agent')) {
                    await llmOptimizeAgents();
                } else if (lowerMessage.includes('status') || lowerMessage.includes('report')) {
                    addChatMessage('system', `üìä System Status: Capital ${STATE.trading.capital.toFixed(2)} | Trades: ${STATE.trading.totalTrades} | Agents: ${agentSystem.agents.size} | Database: ${STATE.database.configured ? 'Connected' : 'Not configured'}`);
                } else if (lowerMessage.includes('generate') && lowerMessage.includes('report')) {
                    await generateSystemReport();
                } else if (lowerMessage.includes('backup')) {
                    createManualBackup();
                } else if (lowerMessage.includes('analyze') || lowerMessage.includes('analysis')) {
                    analyzeHistoricalData();
                } else if (lowerMessage.includes('start') && lowerMessage.includes('trad')) {
                    if (!STATE.trading.isAutoTrading) toggleAutonomousTrading();
                } else if (lowerMessage.includes('stop') || lowerMessage.includes('halt') || lowerMessage.includes('emergency')) {
                    if (STATE.trading.isAutoTrading) emergencyStop();
                } else if (lowerMessage.includes('wallet')) {
                    openWalletManager();
                } else if (lowerMessage.includes('node') || lowerMessage.includes('network')) {
                    openNodeManager();
                } else if (lowerMessage.includes('agent')) {
                    addChatMessage('system', `ü§ñ Active Agents: ${Array.from(agentSystem.agents.values()).map(a => a.name).join(', ')}`);
                } else if (lowerMessage.includes('help') || lowerMessage.includes('command')) {
                    addChatMessage('system', 'üí° Commands: status, backup, analyze, start/stop trading, wallet, node, agent, health, optimize, generate report, llm help');
                } else if (lowerMessage.includes('health')) {
                    performSystemHealthCheck();
                } else if (lowerMessage.includes('optim')) {
                    optimizeSystem();
                } else {
                    const responses = [
                        `ü§ñ METABOTPRIME LLM analyzing: "${message}"`,
                        'üìä Processing request with enhanced AI agents...',
                        'üß† Cross-referencing market data with LLM intelligence...',
                        '‚ö° LLM system ready - processing your request...',
                        'üéØ Request acknowledged - type "llm help" for LLM commands'
                    ];
                    addChatMessage('llm', responses[Math.floor(Math.random() * responses.length)]);

                    // Auto-suggest LLM help for complex queries
                    if (message.length > 20) {
                        setTimeout(() => {
                            addChatMessage('llm', 'üí° For complex tasks, try LLM assistance: "llm diagnose" or "llm help"');
                        }, 1500);
                    }
                }
            }, 300);
        }

        function addChatMessage(sender, message) {
            const chatLog = document.getElementById('chat-log');
            if (!chatLog) return;

            const messageDiv = document.createElement('div');
            const colors = {
                'system': '#00ff88',
                'trading': '#0088ff',
                'database': '#ff00ff',
                'agent': '#ffaa00',
                'wallet': '#00ffff',
                'network': '#ff8800',
                'admin': '#ff0066',
                'emergency': '#ff0000',
                'security': '#ff00ff',
                'repair': '#ff6600',
                'user': '#ffffff',
                'llm': '#00c8ff',
                'report': '#88ff00'
            };

            messageDiv.innerHTML = `<span style="color: ${colors[sender] || '#ffffff'}; font-weight: bold;">[${sender.toUpperCase()}]:</span> <span style="color: #cccccc;">${message}</span>`;
            messageDiv.style.marginBottom = '3px';
            messageDiv.style.fontSize = '10px';
            messageDiv.style.padding = '2px';

            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;

            // Keep chat history manageable
            while (chatLog.children.length > 100) {
                chatLog.removeChild(chatLog.firstChild);
            }
        }

        // Utility Functions
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function updateSystemStatus() {
            // Update uptime
            const uptime = Date.now() - startTime;
            const hours = Math.floor(uptime / 3600000);
            const minutes = Math.floor((uptime % 3600000) / 60000);
            const seconds = Math.floor((uptime % 60000) / 1000);
            document.getElementById('uptime').textContent =
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // Update learning progress based on actual activity
            if (STATE.trading.totalTrades > 0) {
                const patternProgress = Math.min(100, STATE.trading.totalTrades * 2);
                const riskProgress = Math.min(100, (STATE.trading.successfulTrades / Math.max(1, STATE.trading.totalTrades)) * 100);
                const timingProgress = Math.min(100, (Date.now() - startTime) / 3600000 * 10); // 10% per hour

                document.getElementById('pattern-progress').style.width = patternProgress + '%';
                document.getElementById('risk-progress').style.width = riskProgress + '%';
                document.getElementById('timing-progress').style.width = timingProgress + '%';
            }

            // Update database UI if configured
            if (dbManager && dbManager.isConfigured) {
                dbManager.updateDatabaseUI();
            }

            // Update LLM status based on processing state
            if (STATE.llm.isProcessing) {
                document.getElementById('llm-status').textContent = 'Processing...';
            } else if (STATE.llm.fallbackMode) {
                document.getElementById('llm-status').textContent = 'Fallback Mode';
            } else {
                document.getElementById('llm-status').textContent = 'Ready';
            }
        }

        // Particle System
        function initializeParticles() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Create particles
            for (let i = 0; i < 80; i++) {
                particles.push(new Particle());
            }

            function animate() {
                ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw(ctx);
                });

                requestAnimationFrame(animate);
            }
            animate();
        }

        class Particle {
            constructor() {
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 2 + 0.5;
                this.opacity = Math.random() * 0.4 + 0.1;
                this.hue = this.getHue();
                this.life = 1.0;
                this.decay = Math.random() * 0.002 + 0.001;
            }

            getHue() {
                if (STATE.llm.isProcessing) return 200; // Blue when LLM processing
                if (STATE.trading.isAutoTrading) return 120; // Green when trading
                if (STATE.user.isLoggedIn) return 240; // Blue when logged in
                return 180; // Cyan default
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > window.innerWidth) this.vx *= -1;
                if (this.y < 35 || this.y > window.innerHeight) this.vy *= -1;

                this.life -= this.decay;
                if (this.life <= 0) {
                    this.life = 1.0;
                    this.x = Math.random() * window.innerWidth;
                    this.y = Math.random() * (window.innerHeight - 35) + 35;
                }

                this.hue = this.getHue();
            }

            draw(ctx) {
                ctx.globalAlpha = this.opacity * this.life;
                ctx.fillStyle = `hsl(${this.hue}, 80%, 60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Window resize handler
            window.addEventListener('resize', () => {
                const canvas = document.getElementById('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (event) => {
                if (!STATE.user.isLoggedIn) return;

                if (event.ctrlKey || event.metaKey) {
                    switch (event.key.toLowerCase()) {
                        case 't':
                            event.preventDefault();
                            if (STATE.trading.initialized) toggleAutonomousTrading();
                            break;
                        case 's':
                            event.preventDefault();
                            if (STATE.trading.isAutoTrading) emergencyStop();
                            break;
                        case 'w':
                            event.preventDefault();
                            openWalletManager();
                            break;
                        case 'n':
                            event.preventDefault();
                            openNodeManager();
                            break;
                        case 'b':
                            event.preventDefault();
                            if (dbManager && dbManager.isConfigured) createManualBackup();
                            break;
                        case 'h':
                            event.preventDefault();
                            performSystemHealthCheck();
                            break;
                        case 'r':
                            event.preventDefault();
                            generateSystemReport();
                            break;
                        case 'l':
                            event.preventDefault();
                            llmDiagnose();
                            break;
                    }
                }
            });

            // Auto-save user preferences
            setInterval(() => {
                if (STATE.user.isLoggedIn) {
                    const preferences = {
                        panels: Array.from(STATE.panels.minimized),
                        lastActivity: Date.now()
                    };
                    localStorage.setItem('metabotprime_prefs', JSON.stringify(preferences));
                }
            }, 30000); // Every 30 seconds
        }

        // System Loops
        function startSystemLoops() {
            // Update system status every second
            setInterval(updateSystemStatus, 1000);

            // Execute agents periodically
            setInterval(() => {
                if (agentSystem && agentSystem.initialized) {
                    agentSystem.agents.forEach(agent => {
                        if (agent.status === 'active' && Math.random() < 0.08) { // 8% chance per cycle
                            agent.execute();
                        }
                    });
                }
            }, 15000); // Every 15 seconds

            // Update node stats in admin panel
            setInterval(() => {
                if (document.getElementById('node-modal').style.display === 'flex') {
                    updateNodeStats();
                }
            }, 5000);

            // LLM health check
            setInterval(() => {
                if (STATE.llm.isProcessing) {
                    // Check for stuck LLM processes
                    const currentTime = Date.now();
                    const lastAction = STATE.llm.lastAction || currentTime;

                    if (currentTime - lastAction > STATE.llm.timeout * 2) {
                        addChatMessage('llm', '‚ö†Ô∏è LLM timeout detected - resetting to fallback mode');
                        STATE.llm.isProcessing = false;
                        STATE.llm.fallbackMode = true;
                        notificationManager.show('LLM timeout - switched to fallback mode', 'warning');
                    }
                }

                // Reset fallback mode after some time
                if (STATE.llm.fallbackMode && Math.random() < 0.1) {
                    STATE.llm.fallbackMode = false;
                    addChatMessage('llm', 'üîÑ LLM fallback mode reset - system ready');
                }
            }, 10000); // Every 10 seconds

            // Auto-generate reports periodically
            if (STATE.user.accessLevel === 'superadmin') {
                setInterval(async () => {
                    if (STATE.trading.totalTrades > 0 && Math.random() < 0.05) { // 5% chance
                        addChatMessage('report', 'üìã Auto-generating periodic system report...');
                        await generateSystemReport();
                    }
                }, 60000); // Every minute
            }
        }

        // Initialize everything when page loads
        window.addEventListener('load', async () => {
            await initializeSystem();
            startSystemLoops();

            // Load user preferences if available
            try {
                const prefs = JSON.parse(localStorage.getItem('metabotprime_prefs') || '{}');
                if (prefs.panels) {
                    STATE.panels.minimized = new Set(prefs.panels);
                }
            } catch (e) {
                console.log('No previous preferences found');
            }

            // Welcome message
            setTimeout(() => {
                addChatMessage('system', 'ü§ñ METABOTPRIME Enhanced v6.2 initialized successfully');
                addChatMessage('llm', 'üß† LLM integration active - Enhanced automation and issue resolution');
                addChatMessage('system', 'üîß Configure database to begin trading operations');
                addChatMessage('llm', 'üí° Try "llm help" for intelligent assistance commands');
            }, 1000);
        });

        // Log system info
        console.log('ü§ñ METABOTPRIME Enhanced v6.2 - LLM-Powered Trading AI');
        console.log('üß† New Features: LLM Integration, Advanced Automation, Enhanced Error Recovery');
        console.log('üîê Super Admin Access: LeaderMasterShake only');
        console.log('üöÄ Features: Multi-Agent System, Database Management, Wallet Integration, Node Network, LLM Assistance');
        console.log('‚å®Ô∏è Keyboard Shortcuts: Ctrl+T (Trading), Ctrl+S (Stop), Ctrl+W (Wallets), Ctrl+N (Nodes), Ctrl+B (Backup), Ctrl+H (Health), Ctrl+R (Report), Ctrl+L (LLM Diagnose)');
        console.log('ü§ñ LLM Commands: "llm diagnose", "llm configure database", "llm optimize agents", "llm help"');
    </script>
</body>
</html>
